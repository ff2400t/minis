<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF/Image OCR & Text Overlay Tool</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- PDF.js -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"
    ></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    </script>

    <!-- Tesseract.js -->
    <script
      src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"
    ></script>

    <!-- jsPDF -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    ></script>

    <style>
      /* Custom scrollbar for text areas */
      .custom-scrollbar::-webkit-scrollbar {
        width: 8px;
      }
      .custom-scrollbar::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 4px;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
    </style>
  </head>
  <body class="bg-slate-50 text-slate-800 min-h-screen font-sans">
    <!-- Main Haunted Web Component -->
    <ocr-app></ocr-app>

    <script type="module">
      // Load haunted and its dependencies from CDN
      import { html, render } from "https://unpkg.com/lit-html?module";
      import {
        component,
        useCallback,
        useEffect,
        useMemo,
        useState,
      } from "https://unpkg.com/haunted?module";
      const { jsPDF } = window.jspdf;

      // --- GLOBAL UTILITIES ---

      /**
       * Parses a string like "1, 3-5, 8" into a sorted array of unique page numbers.
       */
      function parsePageRange(rangeStr, maxPage) {
        const pages = new Set();
        const parts = rangeStr.split(",").map((s) => s.trim()).filter(
          (s) => s.length > 0,
        );

        for (const part of parts) {
          if (part.includes("-")) {
            const [startStr, endStr] = part.split("-").map((s) =>
              s.trim()
            );
            const start = parseInt(startStr, 10);
            const end = parseInt(endStr, 10);

            if (
              isNaN(start) || isNaN(end) || start < 1 ||
              end > maxPage || start > end
            ) {
              return null; // Invalid range or bounds
            }

            for (let i = start; i <= end; i++) {
              pages.add(i);
            }
          } else {
            const pageNum = parseInt(part, 10);
            if (isNaN(pageNum) || pageNum < 1 || pageNum > maxPage) {
              return null; // Invalid single page number
            }
            pages.add(pageNum);
          }
        }
        return Array.from(pages).sort((a, b) => a - b);
      }

      // --- HOOK: useAppState for centralized logic ---

      function useAppState() {
        const [appMode, setAppMode] = useState("IDLE"); // 'IDLE', 'LOADED', 'PROCESSING', 'COMPLETED'
        const [pdfDoc, setPdfDoc] = useState(null);
        const [processedPagesData, setProcessedPagesData] = useState(
          [],
        );
        const [processedJobCount, setProcessedJobCount] = useState(0);
        const [scheduler, setScheduler] = useState(null);
        const [currentWorkerCount, setCurrentWorkerCount] = useState(0);
        const [maxPage, setMaxPage] = useState(0);
        const [pagesToProcess, setPagesToProcess] = useState([]);
        const [workerCount, setWorkerCount] = useState(4);
        const [showResults, setShowResults] = useState(true);
        const [pageRangeInput, setPageRangeInput] = useState("");
        const [pageSelection, setPageSelection] = useState("all");
        const [pageRangeError, setPageRangeError] = useState(false);
        const [progress, setProgress] = useState({
          percent: 0,
          text: "Ready to upload file.",
        });
        const [inputType, setInputType] = useState("NONE"); // 'NONE', 'PDF', 'IMAGE'

        const isProcessing = appMode === "PROCESSING";

        // --- Handlers ---

        const handleFileSelect = useCallback(async (file) => {
          if (!file || isProcessing) return;

          const mimeType = file.type;
          const isPdf = mimeType === "application/pdf";
          const isImage = mimeType.startsWith("image/");

          if (!isPdf && !isImage) return;

          // Reset state
          setAppMode("PROCESSING");
          setInputType(isPdf ? "PDF" : "IMAGE");
          setProcessedJobCount(0);
          setProcessedPagesData([]);
          setPageRangeError(false);
          setPdfDoc(null);
          setMaxPage(0);
          setProgress({
            percent: 0,
            text: `Loading ${isPdf ? "PDF" : "Image"} file...`,
          });

          try {
            if (isPdf) {
              // PDF Loading Logic
              const arrayBuffer = await file.arrayBuffer();
              const doc = await pdfjsLib.getDocument(arrayBuffer)
                .promise;
              const numPages = doc.numPages;

              setPdfDoc(doc);
              setMaxPage(numPages);
              setAppMode("LOADED");
              setProgress({
                percent: 0,
                text: `PDF loaded. ${numPages} page(s) available.`,
              });
            } else if (isImage) {
              // Image Loading Logic
              const imgData = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
              });

              // Set the single image as the initial page data (PageNum 1)
              setProcessedPagesData([{
                pageNum: 1,
                imgData: imgData,
                status: "Image loaded. Ready for OCR.",
                text: "",
                width: 0, // Will be determined later
                height: 0,
              }]);
              setMaxPage(1);
              setAppMode("LOADED");
              setProgress({
                percent: 0,
                text: `Image loaded. Ready to process 1 page.`,
              });
            }
          } catch (err) {
            console.error("Error loading file:", err);
            setAppMode("IDLE");
            setProgress({
              percent: 0,
              text: `Error loading file: ${err.message}`,
            });
          }
        }, [isProcessing]);

        const processPage = useCallback(
          async (
            pageNum,
            totalJobs,
            doc,
            schedulerInstance,
            currentInputType,
          ) => {
            const pageIndex = processedPagesData.findIndex((p) =>
              p.pageNum === pageNum
            );
            let imgData;
            let width, height;
            let statusMsg = "Rendering & OCR Queued...";

            if (currentInputType === "PDF") {
              // 1. PDF Rendering Logic
              statusMsg = "Rendering...";
              setProcessedPagesData((prev) => {
                const newData = [...prev];
                if (newData[pageIndex]) {
                  newData[pageIndex].status = statusMsg;
                }
                return newData;
              });

              const page = await doc.getPage(pageNum);
              // Use scale 2.0 for higher quality OCR input
              const viewport = page.getViewport({ scale: 2.0 });

              const renderCanvas = document.createElement("canvas");
              renderCanvas.height = viewport.height;
              renderCanvas.width = viewport.width;

              const renderContext = {
                canvasContext: renderCanvas.getContext("2d"),
                viewport: viewport,
              };

              await page.render(renderContext).promise;
              imgData = renderCanvas.toDataURL("image/jpeg", 0.8);
              width = viewport.width;
              height = viewport.height;
            } else if (currentInputType === "IMAGE") {
              // 1. Image Load Logic (data is already in processedPagesData)
              imgData = processedPagesData[pageIndex].imgData;
              statusMsg = "Preparing image...";

              setProcessedPagesData((prev) => {
                const newData = [...prev];
                if (newData[pageIndex]) {
                  newData[pageIndex].status = statusMsg;
                }
                return newData;
              });

              // Get actual dimensions for jsPDF format
              const img = new Image();
              await new Promise((resolve) => {
                img.onload = resolve;
                img.src = imgData;
              });
              width = img.width;
              height = img.height;
            }

            // 2. Display Image on UI Canvas (Crucial side effect outside state)
            if (showResults) {
              const uiCanvas = document.getElementById(
                `canvas-${pageNum}`,
              );
              if (uiCanvas) {
                // Scale down for display purposes
                uiCanvas.height = height / 2;
                uiCanvas.width = width / 2;
                const ctx = uiCanvas.getContext("2d");
                const img = new Image();
                img.onload = () => {
                  ctx.drawImage(
                    img,
                    0,
                    0,
                    uiCanvas.width,
                    uiCanvas.height,
                  );
                };
                img.src = imgData;
              }
            }

            // 3. Perform OCR
            setProcessedPagesData((prev) => {
              const newData = [...prev];
              if (newData[pageIndex]) {
                newData[pageIndex].status = "OCR Processing...";
              }
              return newData;
            });

            const result = await schedulerInstance.addJob(
              "recognize",
              imgData,
            );
            const { text, words } = result.data;

            // 4. Store result
            setProcessedPagesData((prev) => {
              const newData = [...prev];
              newData[pageIndex] = {
                pageNum,
                imgData: imgData,
                width: width,
                height: height,
                words: words,
                text: text,
                status: "Completed",
              };
              return newData;
            });

            setProcessedJobCount((prev) => {
              const newCount = prev + 1;
              const percent = Math.round((newCount / totalJobs) * 100);
              setProgress({
                percent: percent,
                text:
                  `OCR complete for page ${pageNum} (${newCount} of ${totalJobs})...`,
              });
              return newCount;
            });
          },
          [processedPagesData, showResults],
        );

        const startProcessing = useCallback(async () => {
          // Guards for starting process
          if (appMode !== "LOADED") return;
          if (inputType === "PDF" && !pdfDoc) return;
          if (inputType === "IMAGE" && maxPage !== 1) return;

          setAppMode("PROCESSING");
          setProcessedJobCount(0);
          setPageRangeError(false);
          setProgress({
            percent: 0,
            text: "Preparing processing job...",
          });

          try {
            // 1. Determine Pages to Process
            let selectedPages = [];
            if (inputType === "IMAGE") {
              // Image input is always page 1
              selectedPages = [1];
            } else if (pageSelection === "all") {
              for (let i = 1; i <= maxPage; i++) {
                selectedPages.push(i);
              }
            } else {
              const parsedPages = parsePageRange(
                pageRangeInput,
                maxPage,
              );
              if (!parsedPages || parsedPages.length === 0) {
                setPageRangeError(true);
                setAppMode("LOADED");
                throw new Error("Invalid page selection.");
              }
              selectedPages = parsedPages;
            }
            setPagesToProcess(selectedPages);
            const totalJobs = selectedPages.length;

            // 2. Scheduler Setup & Worker Creation (same logic for both PDF and Image)
            let schedulerInstance = scheduler;
            const requestedWorkerCount = workerCount;

            if (
              !schedulerInstance ||
              currentWorkerCount !== requestedWorkerCount
            ) {
              if (schedulerInstance) {
                setProgress({
                  percent: 0,
                  text: `Terminating old workers...`,
                });
                await schedulerInstance.terminate();
                schedulerInstance = null;
              }

              setProgress({
                percent: 0,
                text:
                  `Initializing ${requestedWorkerCount} OCR workers...`,
              });
              schedulerInstance = Tesseract.createScheduler();
              const workerPromises = [];
              for (let i = 0; i < requestedWorkerCount; i++) {
                workerPromises.push(Tesseract.createWorker("eng"));
              }

              const workers = await Promise.all(workerPromises);
              workers.forEach((worker) =>
                schedulerInstance.addWorker(worker)
              );
              setScheduler(schedulerInstance);
              setCurrentWorkerCount(requestedWorkerCount);
            }

            // 3. Initialize processedPagesData status
            if (inputType === "PDF") {
              setProcessedPagesData(selectedPages.map((pageNum) => ({
                pageNum,
                status: "Rendering & OCR Queued...",
                text: "",
              })));
            } else {
              // For image, update status but keep existing data loaded in handleFileSelect
              setProcessedPagesData((prev) =>
                prev.map((p) => ({ ...p, status: "OCR Queued..." }))
              );
            }

            // 4. Start concurrent page processing
            setProgress({
              percent: 0,
              text: `${
                inputType === "PDF"
                  ? "Rendering pages"
                  : "Processing image"
              } for OCR...`,
            });
            const jobPromises = selectedPages.map((pageNum) =>
              processPage(
                pageNum,
                totalJobs,
                pdfDoc,
                schedulerInstance,
                inputType,
              )
            );

            await Promise.all(jobPromises);

            // 5. Finalize
            setAppMode("COMPLETED");
            setProgress({
              percent: 100,
              text:
                `Done! Processed ${totalJobs} page(s). Ready to download.`,
            });
          } catch (err) {
            console.error("OCR Process Error:", err);
            setAppMode("LOADED");
            setProgress({
              percent: 0,
              text: `Error during processing: ${err.message}`,
            });
          }
        }, [
          appMode,
          pdfDoc,
          pageSelection,
          maxPage,
          pageRangeInput,
          workerCount,
          scheduler,
          currentWorkerCount,
          processPage,
          inputType,
        ]);

        const generateSearchablePDF = useCallback(async () => {
          if (
            appMode !== "COMPLETED" || processedPagesData.length === 0
          ) return;

          // Sort data by page number to ensure PDF pages are in the correct order
          const sortedData = [...processedPagesData].sort((a, b) =>
            a.pageNum - b.pageNum
          );

          setProgress({ percent: 100, text: "Generating PDF file..." });

          try {
            const firstPage = sortedData[0];
            // jsPDF format expects units, use first page dimensions for setup
            const doc = new jsPDF({
              orientation: firstPage.width > firstPage.height
                ? "landscape"
                : "portrait",
              unit: "px",
              format: [firstPage.width, firstPage.height],
            });

            // Add font support for better text overlay, though this is a complex topic
            // doc.setFont("helvetica"); // Default font

            sortedData.forEach((pageData, index) => {
              if (index > 0) {
                // Add new page with correct dimensions if it's not the first page
                doc.addPage([pageData.width, pageData.height]);
              }

              const width = pageData.width;
              const height = pageData.height;

              // 1. Add the original image as background
              doc.addImage(
                pageData.imgData,
                "JPEG",
                0,
                0,
                width,
                height,
              );

              // 2. Add invisible text overlay
              doc.setFontSize(12);
              doc.setTextColor(255, 255, 255); // White text
              doc.internal.write("3 Tr"); // Text Rendering Mode 3 (Invisible)

              pageData.words.forEach((word) => {
                const { text, bbox } = word;
                // Calculate font size based on word height
                const h = bbox.y1 - bbox.y0;
                const fontSize = h * 0.9;
                doc.setFontSize(fontSize);
                // Adjust coordinates for PDF space (y-coordinates need adjustment for bottom baseline)
                doc.text(text, bbox.x0, bbox.y1, {
                  baseline: "bottom",
                });
              });
            });

            const fileName = inputType === "IMAGE"
              ? "ocr-image-to-pdf.pdf"
              : "ocr-searchable-pdf.pdf";
            doc.save(fileName);
            setProgress({
              percent: 100,
              text:
                "PDF downloaded successfully! Upload a new file to start over.",
            });
          } catch (err) {
            console.error(err);
            setProgress({ percent: 100, text: "Error creating PDF." });
          }
        }, [appMode, processedPagesData, inputType]);

        return {
          appMode,
          setAppMode,
          processedPagesData,
          progress,
          isProcessing,
          inputType,
          maxPage,
          setMaxPage,
          workerCount,
          setWorkerCount,
          showResults,
          setShowResults,
          pageRangeInput,
          setPageRangeInput,
          pageSelection,
          setPageSelection,
          pageRangeError,
          setPageRangeError,
          handleFileSelect,
          startProcessing,
          generateSearchablePDF,
        };
      }

      // --- COMPONENTS ---

      const Header = () =>
        html`
          <header class="bg-white border-b border-slate-200 sticky top-0 z-50">
            <div
              class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex items-center justify-center"
            >
              <div class="flex items-center gap-2">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-8 w-8 text-blue-600"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                  />
                </svg>
                <h1 class="text-xl font-bold text-slate-900">
                  OCR Overlay Tool (PDF & Images)
                </h1>
              </div>
            </div>
          </header>
        `;

      const UploadArea = ({ handleFileSelect, isProcessing }) =>
        html`
          <div id="uploadSection" class="mb-8">
            <label
              for="fileInput"
              id="dropZone"
              class="
                flex flex-col items-center justify-center w-full h-32 border-2 border-slate-300 border-dashed rounded-lg cursor-pointer bg-white hover:bg-slate-50 transition-all
                ${isProcessing ? "opacity-50 cursor-not-allowed" : ""}
              "
            >
              <div
                class="flex flex-col items-center justify-center pt-5 pb-6 pointer-events-none"
              >
                <svg
                  class="w-8 h-8 mb-3 text-slate-400"
                  aria-hidden="true"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 20 16"
                >
                  <path
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"
                  />
                </svg>
                <p class="text-sm text-slate-500">
                  <span class="font-semibold">Click to upload PDF or Image</span>
                  or drag and drop
                </p>
                <p class="text-xs text-slate-400 mt-1">
                  PDF, JPG, PNG files only (No external servers are used)
                </p>
              </div>
              <input
                id="fileInput"
                type="file"
                accept="application/pdf,image/jpeg,image/png"
                class="hidden"
                @change="${(e) => handleFileSelect(e.target.files[0])}"
                ?disabled="${isProcessing}"
                @click="${(e) => {
                  // Clear input if re-uploading the same file to trigger change event
                  if (!isProcessing) e.target.value = null;
                }}"
              />
            </label>
          </div>
        `;

      const OptionsPanel = ({
        appMode,
        isProcessing,
        maxPage,
        workerCount,
        setWorkerCount,
        showResults,
        setShowResults,
        pageRangeInput,
        setPageRangeInput,
        pageSelection,
        setPageSelection,
        pageRangeError,
        setPageRangeError,
        inputType,
      }) => {
        const isVisible = appMode !== "IDLE";

        return html`
          <div
            class="bg-white p-6 rounded-xl shadow-sm border border-slate-200 mb-8 ${isVisible
              ? ""
              : "hidden"}"
          >
            <h2 class="text-lg font-semibold text-slate-700 mb-4">
              Processing Options
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- 1. Page Selection (Hidden for Image Input) -->
              <div class="${inputType === "IMAGE"
                ? "hidden"
                : "block"}">
                <label class="block text-sm font-medium text-slate-700 mb-2"
                >Pages to OCR</label>
                <div class="flex items-center gap-4">
                  <div class="flex items-center">
                    <input
                      id="allPagesRadio"
                      name="pageSelection"
                      type="radio"
                      .checked="${pageSelection === "all"}"
                      @change="${() => {
                        setPageSelection("all");
                        setPageRangeError(false);
                      }}"
                      class="h-4 w-4 text-blue-600 border-slate-300 focus:ring-blue-500"
                      value="all"
                      ?disabled="${isProcessing}"
                    >
                    <label
                      for="allPagesRadio"
                      class="ml-2 block text-sm text-slate-900"
                    >All Pages (${maxPage})</label>
                  </div>
                  <div class="flex items-center">
                    <input
                      id="selectPagesRadio"
                      name="pageSelection"
                      type="radio"
                      .checked="${pageSelection === "select"}"
                      @change="${() => {
                        setPageSelection("select");
                        setPageRangeError(false);
                      }}"
                      class="h-4 w-4 text-blue-600 border-slate-300 focus:ring-blue-500"
                      value="select"
                      ?disabled="${isProcessing}"
                    >
                    <label
                      for="selectPagesRadio"
                      class="ml-2 block text-sm text-slate-900"
                    >Select Range/List</label>
                  </div>
                </div>
                <input
                  id="pageRangeInput"
                  type="text"
                  .disabled="${pageSelection === "all" || isProcessing}"
                  .value="${pageRangeInput}"
                  @input="${(e) => {
                    setPageRangeInput(e.target.value);
                    setPageRangeError(false);
                  }}"
                  placeholder="e.g., 1, 3-5, 8 (Max: ${maxPage})"
                  class="
                    mt-2 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-slate-50 disabled:text-slate-400 text-sm p-2
                    ${pageRangeError
                      ? "border-red-500 ring-red-500"
                      : ""}
                  "
                >
                <p class="mt-1 text-xs text-red-600 ${pageRangeError
                  ? ""
                  : "hidden"}">
                  Invalid page range format or page number out of bounds.
                </p>
              </div>

              <!-- Page Selection for Images (Filler) -->
              <div class="${inputType === "IMAGE"
                ? "block"
                : "hidden"}">
                <label class="block text-sm font-medium text-slate-700 mb-2"
                >Pages to OCR</label>
                <p
                  class="mt-2 block w-full rounded-md border border-slate-200 bg-slate-50 text-slate-600 text-sm p-2"
                >
                  Single image processed as Page 1.
                </p>
              </div>

              <!-- 2. Worker Count -->
              <div class="pl-6 border-slate-100 ${inputType === "PDF"
                ? "border-l"
                : ""}">
                <label
                  for="workerCountInput"
                  class="block text-sm font-medium text-slate-700 mb-2"
                >OCR Workers (Threads)</label>
                <input
                  id="workerCountInput"
                  type="number"
                  .value="${workerCount}"
                  @change="${(e) =>
                    setWorkerCount(parseInt(e.target.value, 10))}"
                  min="1"
                  max="8"
                  class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm p-2"
                  title="The number of parallel workers Tesseract will use for OCR. Recommended: 2-4"
                  ?disabled="${isProcessing}"
                >
                <p class="text-xs text-slate-400 mt-1">
                  More workers = faster processing, higher memory use.
                </p>
              </div>

              <!-- 3. Toggle Display -->
              <div class="pl-6 border-l border-slate-100">
                <label
                  for="showResultsToggle"
                  class="relative inline-flex items-center cursor-pointer mb-2"
                >
                  <input
                    type="checkbox"
                    id="showResultsToggle"
                    .checked="${showResults}"
                    @change="${(e) => setShowResults(e.target.checked)}"
                    class="sr-only peer"
                  >
                  <div
                    class="w-11 h-6 bg-slate-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-slate-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"
                  >
                  </div>
                  <span class="ml-3 text-sm font-medium text-slate-700"
                  >Show Page Results</span>
                </label>
                <p class="text-xs text-slate-400 mt-1">
                  Hide to speed up processing on very large documents.
                </p>
              </div>
            </div>
          </div>
        `;
      };

      const MainActionButton = (
        { appMode, startProcessing, generateSearchablePDF, inputType },
      ) => {
        let text = "";
        let action = () => {};
        let disabled = true;
        let className =
          "bg-slate-200 text-slate-400 cursor-not-allowed";

        if (appMode === "LOADED") {
          text = "Start Processing";
          action = startProcessing;
          disabled = false;
          className =
            "bg-blue-600 text-white hover:bg-blue-700 shadow-lg";
        } else if (appMode === "PROCESSING") {
          text = "Processing...";
          disabled = true;
          className = "bg-slate-400 text-white cursor-wait";
        } else if (appMode === "COMPLETED") {
          text = inputType === "IMAGE"
            ? "Generate PDF"
            : "Download Searchable PDF";
          action = generateSearchablePDF;
          disabled = false;
          className =
            "bg-green-600 text-white hover:bg-green-700 shadow-lg";
        } else {
          return html`

          `;
        }

        return html`
          <button
            @click="${action}"
            ?disabled="${disabled}"
            class="w-full mb-8 flex justify-center items-center gap-2 px-4 py-3 rounded-lg font-medium transition-colors ${className}"
          >
            ${text}
          </button>
        `;
      };

      const ProgressBar = ({ appMode, progress }) => {
        const isVisible = appMode === "PROCESSING" ||
          appMode === "COMPLETED";

        return html`
          <div id="globalProgress" class="mb-8 ${isVisible
            ? ""
            : "hidden"}">
            <div class="flex justify-between mb-1">
              <span id="statusText" class="text-sm font-medium text-blue-700"
              >${progress.text}</span>
              <span id="percentageText" class="text-sm font-medium text-blue-700"
              >${progress.percent}%</span>
            </div>
            <div class="w-full bg-slate-200 rounded-full h-2.5">
              <div
                id="progressBar"
                class="bg-blue-600 h-2.5 rounded-full transition-all duration-300"
                style="width: ${progress.percent}%"
              >
              </div>
            </div>
          </div>
        `;
      };

      const PageResult = ({ page }) => {
        const statusColor = page.status === "Completed"
          ? "bg-green-500"
          : "bg-blue-500 animate-pulse";
        const statusTextClass = page.status === "Completed"
          ? "text-green-600"
          : "text-blue-600";

        // Function must be defined here for the component's scope
        const copyText = (e) => {
          const textarea = e.target.closest(".p-4.flex.flex-col")
            .querySelector("textarea");
          textarea.select();
          document.execCommand("copy");
          const originalText = e.target.textContent;
          e.target.textContent = "Copied!";
          setTimeout(() => e.target.textContent = originalText, 2000);
        };

        return html`
          <div
            class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden"
          >
            <div
              class="border-b border-slate-100 bg-slate-50 px-4 py-3 flex justify-between items-center"
            >
              <h3 class="font-semibold text-slate-700">Page ${page
                .pageNum}</h3>
              <div
                class="status-indicator flex items-center gap-2 text-xs font-medium text-slate-500"
              >
                <span class="status-dot w-2 h-2 rounded-full ${statusColor}"></span>
                <span class="status-text ${statusTextClass}">${page
                  .status}</span>
              </div>
            </div>
            <div
              class="grid grid-cols-1 md:grid-cols-2 divide-y md:divide-y-0 md:divide-x divide-slate-100"
            >
              <!-- Image Column -->
              <div
                class="p-4 bg-slate-50/50 flex items-start justify-center overflow-auto max-h-[600px] custom-scrollbar"
              >
                <!-- Canvas ID must match the one referenced in the processPage hook logic -->
                <canvas
                  id="canvas-${page.pageNum}"
                  class="pdf-canvas shadow-lg max-w-full h-auto"
                ></canvas>
              </div>
              <!-- Text Column -->
              <div class="p-4 flex flex-col h-[600px]">
                <div class="flex justify-between items-center mb-2">
                  <span
                    class="text-xs font-semibold text-slate-400 uppercase tracking-wider"
                  >Extracted Text</span>
                  <button
                    @click="${copyText}"
                    class="copy-btn text-xs text-blue-600 hover:text-blue-800 font-medium"
                  >
                    Copy Text
                  </button>
                </div>
                <textarea
                  class="extracted-text w-full flex-1 p-3 text-sm text-slate-700 border border-slate-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none resize-none custom-scrollbar font-mono leading-relaxed bg-white"
                  readonly
                  placeholder="Text will appear here after processing..."
                >${page.text}</textarea>
              </div>
            </div>
          </div>
        `;
      };

      const ResultsArea = (
        { processedPagesData, showResults, appMode },
      ) => {
        const isVisible = showResults &&
          (appMode === "PROCESSING" || appMode === "COMPLETED");

        return html`
          <div id="resultsContainer" class="space-y-12 ${isVisible
            ? ""
            : "hidden"}">
            ${processedPagesData.map((page) =>
              html`
                <div class="page-result">${PageResult({ page })}</div>
              `
            )}
          </div>
        `;
      };

      // --- MAIN APP COMPONENT ---

      function App() {
        // Destructure all values and handlers from the custom hook
        const {
          appMode,
          processedPagesData,
          progress,
          isProcessing,
          inputType,
          maxPage,
          workerCount,
          setWorkerCount,
          showResults,
          setShowResults,
          pageRangeInput,
          setPageRangeInput,
          pageSelection,
          setPageSelection,
          pageRangeError,
          setPageRangeError,
          handleFileSelect,
          startProcessing,
          generateSearchablePDF,
        } = useAppState();

        return html`
          ${Header()}
          <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            ${UploadArea({
              handleFileSelect,
              isProcessing,
            })} ${OptionsPanel({
              appMode,
              isProcessing,
              maxPage,
              workerCount,
              setWorkerCount,
              showResults,
              setShowResults,
              pageRangeInput,
              setPageRangeInput,
              pageSelection,
              setPageSelection,
              pageRangeError,
              setPageRangeError,
              inputType,
            })} ${MainActionButton({
              appMode,
              startProcessing,
              generateSearchablePDF,
              inputType,
            })} ${ProgressBar({ appMode, progress })} ${ResultsArea({
              processedPagesData,
              showResults,
              appMode,
            })}
          </main>
        `;
      }

      // Register the main application component
      customElements.define(
        "ocr-app",
        component(App, { useShadowDOM: false }),
      );
    </script>
  </body>
</html>
