<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF OCR & Text Overlay Tool</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- PDF.js -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"
    ></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    </script>

    <!-- Tesseract.js -->
    <script
      src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"
    ></script>

    <!-- jsPDF -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    ></script>

    <style>
      /* Custom scrollbar for text areas */
      .custom-scrollbar::-webkit-scrollbar {
        width: 8px;
      }
      .custom-scrollbar::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 4px;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
      .loader {
        border: 3px solid #f3f3f3;
        border-radius: 50%;
        border-top: 3px solid #3b82f6;
        width: 24px;
        height: 24px;
        -webkit-animation: spin 1s linear infinite; /* Safari */
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body class="bg-slate-50 text-slate-800 min-h-screen font-sans">
    <!-- Header -->
    <header class="bg-white border-b border-slate-200 sticky top-0 z-50">
      <div
        class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex items-center justify-between"
      >
        <div class="flex items-center gap-2">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-8 w-8 text-blue-600"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
            />
          </svg>
          <h1 class="text-xl font-bold text-slate-900">OCR Overlay Tool</h1>
        </div>
        <div class="flex gap-3">
          <button
            id="downloadBtn"
            disabled
            class="hidden sm:flex items-center gap-2 px-4 py-2 bg-slate-200 text-slate-400 rounded-lg font-medium cursor-not-allowed transition-colors"
          >
            <span>Download PDF</span>
          </button>
        </div>
      </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <!-- Upload Section -->
      <div id="uploadSection" class="mb-8">
        <label
          id="dropZone"
          class="flex flex-col items-center justify-center w-full h-32 border-2 border-slate-300 border-dashed rounded-lg cursor-pointer bg-white hover:bg-slate-50 transition-all"
        >
          <div
            class="flex flex-col items-center justify-center pt-5 pb-6 pointer-events-none"
          >
            <svg
              class="w-8 h-8 mb-3 text-slate-400"
              aria-hidden="true"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 20 16"
            >
              <path
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"
              />
            </svg>
            <p class="text-sm text-slate-500">
              <span class="font-semibold">Click to upload PDF</span> or drag and
              drop
            </p>
            <p class="text-xs text-slate-400 mt-1">
              PDF files only (Processing happens locally in your browser)
            </p>
          </div>
          <input
            id="fileInput"
            type="file"
            accept="application/pdf"
            class="hidden"
          />
        </label>
      </div>

      <!-- Global Progress Bar -->
      <div id="globalProgress" class="hidden mb-8">
        <div class="flex justify-between mb-1">
          <span id="statusText" class="text-sm font-medium text-blue-700"
          >Initializing...</span>
          <span id="percentageText" class="text-sm font-medium text-blue-700"
          >0%</span>
        </div>
        <div class="w-full bg-slate-200 rounded-full h-2.5">
          <div
            id="progressBar"
            class="bg-blue-600 h-2.5 rounded-full transition-all duration-300"
            style="width: 0%"
          >
          </div>
        </div>
      </div>

      <!-- Mobile Download Button (Visible only on mobile when ready) -->
      <button
        id="mobileDownloadBtn"
        disabled
        class="w-full mb-6 sm:hidden flex justify-center items-center gap-2 px-4 py-3 bg-slate-200 text-slate-400 rounded-lg font-medium cursor-not-allowed transition-colors"
      >
        Download PDF
      </button>

      <!-- Results Container -->
      <div id="resultsContainer" class="space-y-12">
        <!-- Pages will be injected here -->
      </div>
    </main>

    <!-- Templates -->
    <template id="pageTemplate">
      <div
        class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden"
      >
        <div
          class="border-b border-slate-100 bg-slate-50 px-4 py-3 flex justify-between items-center"
        >
          <h3 class="font-semibold text-slate-700 page-number">Page 1</h3>
          <div
            class="status-indicator flex items-center gap-2 text-xs font-medium text-slate-500"
          >
            <span class="status-dot w-2 h-2 rounded-full bg-slate-300"></span>
            <span class="status-text">Pending</span>
          </div>
        </div>
        <div
          class="grid grid-cols-1 md:grid-cols-2 divide-y md:divide-y-0 md:divide-x divide-slate-100"
        >
          <!-- Image Column -->
          <div
            class="p-4 bg-slate-50/50 flex items-start justify-center overflow-auto max-h-[600px] custom-scrollbar"
          >
            <canvas class="pdf-canvas shadow-lg max-w-full h-auto"></canvas>
          </div>
          <!-- Text Column -->
          <div class="p-4 flex flex-col h-[600px]">
            <div class="flex justify-between items-center mb-2">
              <span
                class="text-xs font-semibold text-slate-400 uppercase tracking-wider"
              >Extracted Text</span>
              <button
                class="copy-btn text-xs text-blue-600 hover:text-blue-800 font-medium"
              >
                Copy Text
              </button>
            </div>
            <textarea
              class="extracted-text w-full flex-1 p-3 text-sm text-slate-700 border border-slate-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none resize-none custom-scrollbar font-mono leading-relaxed bg-white"
              readonly
              placeholder="Text will appear here after processing..."
            ></textarea>
          </div>
        </div>
      </div>
    </template>

    <script>
      const { jsPDF } = window.jspdf;

      // State
      let pdfDoc = null;
      let processedPagesData = []; // Stores { imgData, words: [], width, height } for each page
      let isProcessing = false;

      // DOM Elements
      const fileInput = document.getElementById("fileInput");
      const dropZone = document.getElementById("dropZone");
      const resultsContainer = document.getElementById(
        "resultsContainer",
      );
      const downloadBtn = document.getElementById("downloadBtn");
      const mobileDownloadBtn = document.getElementById(
        "mobileDownloadBtn",
      );
      const globalProgress = document.getElementById("globalProgress");
      const progressBar = document.getElementById("progressBar");
      const statusText = document.getElementById("statusText");
      const percentageText = document.getElementById("percentageText");

      // Initialization
      fileInput.addEventListener("change", (e) => {
        if (e.target.files[0]) processFile(e.target.files[0]);
      });

      // Drag and Drop Listeners
      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("border-blue-500", "bg-blue-50");
      });

      dropZone.addEventListener("dragleave", (e) => {
        e.preventDefault();
        dropZone.classList.remove("border-blue-500", "bg-blue-50");
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("border-blue-500", "bg-blue-50");

        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
          processFile(e.dataTransfer.files[0]);
        }
      });

      downloadBtn.addEventListener("click", generateSearchablePDF);
      mobileDownloadBtn.addEventListener(
        "click",
        generateSearchablePDF,
      );

      async function processFile(file) {
        if (!file || file.type !== "application/pdf") {
          alert("Please upload a valid PDF file.");
          return;
        }

        if (isProcessing) return;
        isProcessing = true;

        // Reset UI
        resultsContainer.innerHTML = "";
        processedPagesData = [];
        disableDownload();
        showProgress(true);
        updateProgress(0, "Loading PDF...");

        try {
          const arrayBuffer = await file.arrayBuffer();
          pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;

          // Process pages sequentially to manage memory and show progress
          for (let i = 1; i <= pdfDoc.numPages; i++) {
            // Update progress BEFORE starting the page
            updateProgress(
              Math.round(((i - 1) / pdfDoc.numPages) * 100),
              `Processing page ${i} of ${pdfDoc.numPages}...`,
            );

            await processPage(i);
          }

          updateProgress(
            100,
            `Done! Processed all ${pdfDoc.numPages} pages.`,
          );
          enableDownload();

          // Hide progress bar after a delay
          setTimeout(() => {
            // Only hide if we aren't starting a new process
            if (!isProcessing) showProgress(false);
          }, 3000);
        } catch (err) {
          console.error(err);
          alert("Error processing PDF: " + err.message);
          showProgress(false);
        } finally {
          isProcessing = false;
          fileInput.value = ""; // Reset input so same file can be selected again if needed
        }
      }

      async function processPage(pageNum) {
        // 1. Create UI Element
        const template = document.getElementById("pageTemplate");
        const clone = template.content.cloneNode(true);
        const pageCard = clone.querySelector("div"); // Root div
        const canvas = clone.querySelector(".pdf-canvas");
        const textArea = clone.querySelector(".extracted-text");
        const pageNumEl = clone.querySelector(".page-number");
        const statusDot = clone.querySelector(".status-dot");
        const statusTextEl = clone.querySelector(".status-text");
        const copyBtn = clone.querySelector(".copy-btn");

        pageNumEl.textContent = `Page ${pageNum}`;
        statusDot.classList.replace("bg-slate-300", "bg-blue-500");
        statusDot.classList.add("animate-pulse");
        statusTextEl.textContent = "Rendering & OCR...";
        statusTextEl.classList.add("text-blue-600");

        resultsContainer.appendChild(clone);

        // 2. Render PDF to Canvas
        const page = await pdfDoc.getPage(pageNum);
        // Scale 2.0 provides better OCR results than 1.0, though slower
        const viewport = page.getViewport({ scale: 2.0 });

        canvas.height = viewport.height;
        canvas.width = viewport.width;

        const renderContext = {
          canvasContext: canvas.getContext("2d"),
          viewport: viewport,
        };

        await page.render(renderContext).promise;

        // 3. Perform OCR
        const worker = await Tesseract.createWorker("eng");

        // Get image data URL for OCR
        const imgData = canvas.toDataURL("image/jpeg", 0.8);

        const result = await worker.recognize(imgData);
        await worker.terminate();

        // 4. Update UI with text
        const text = result.data.text;
        textArea.value = text;

        // Update Status
        statusDot.classList.remove("animate-pulse", "bg-blue-500");
        statusDot.classList.add("bg-green-500");
        statusTextEl.textContent = "Completed";
        statusTextEl.classList.remove("text-blue-600");
        statusTextEl.classList.add("text-green-600");

        // Copy functionality
        copyBtn.addEventListener("click", () => {
          textArea.select();
          document.execCommand("copy");
          const originalText = copyBtn.textContent;
          copyBtn.textContent = "Copied!";
          setTimeout(() => copyBtn.textContent = originalText, 2000);
        });

        // 5. Store data for PDF generation
        // Store the dimensions and the words with their bounding boxes
        processedPagesData.push({
          pageNum,
          imgData: imgData, // The image of the page
          width: viewport.width,
          height: viewport.height,
          words: result.data.words, // Array of { text, bbox: {x0, y0, x1, y1}, ... }
        });
      }

      async function generateSearchablePDF() {
        if (processedPagesData.length === 0) return;

        const btnText = downloadBtn.querySelector("span");
        const originalText = btnText.textContent;
        btnText.textContent = "Generating PDF...";

        try {
          // Initialize jsPDF
          // We will create pages dynamically based on image dimensions
          const doc = new jsPDF({
            orientation: "portrait",
            unit: "px",
            format: [
              processedPagesData[0].width,
              processedPagesData[0].height,
            ],
          });

          processedPagesData.forEach((pageData, index) => {
            if (index > 0) {
              doc.addPage([pageData.width, pageData.height]);
            }

            const width = pageData.width;
            const height = pageData.height;

            // 1. Add the original image as background
            doc.addImage(pageData.imgData, "JPEG", 0, 0, width, height);

            // 2. Add invisible text overlay
            // We need to set text color to transparent (invisible) but selectable
            // jsPDF workaround for invisible text: set render mode to invisible
            // However, standard setTextColor(255,255,255) with 0 opacity is easier for compatibility

            doc.setFontSize(12); // Initial font size, will be scaled
            doc.setTextColor(255, 255, 255); // White

            // This is the "magic" for invisible text in jsPDF.
            // We rely on the text rendering mode 3 (invisible) usually,
            // but jsPDF basic API is limited.
            // We will set the text color to fully transparent white using RGBA logic if supported,
            // or just render it 'invisible' via specific PDF operator if we wanted to be hardcore.
            // Simple approach: standard text, but invisible via rendering mode.

            // Setting rendering mode to '3' (invisible) manually
            doc.internal.write("3 Tr"); // Tr = Text Rendering Mode

            pageData.words.forEach((word) => {
              const { text, bbox } = word;
              // bbox: x0, y0, x1, y1 (in pixels relative to the canvas size)

              const w = bbox.x1 - bbox.x0;
              const h = bbox.y1 - bbox.y0;

              // Calculate font size to match height roughly
              // PDF font size is usually in points. 1px approx 0.75pt.
              // We need to tweak this multiplier to fit the text box roughly.
              const fontSize = h * 0.9;
              doc.setFontSize(fontSize);

              // Calculate position
              // Tesseract baseline is slightly different, we adjust y.
              // PDF text is placed by bottom-left usually, Tesseract is top-left.
              const pdfY = bbox.y1;

              // There is no easy "stretch" in jsPDF without advanced API to perfectly match width.
              // But precise placement makes it searchable enough.
              doc.text(text, bbox.x0, bbox.y1, {
                baseline: "bottom",
              });
            });
          });

          doc.save("ocr-result.pdf");
        } catch (err) {
          console.error(err);
          alert("Error creating PDF");
        } finally {
          btnText.textContent = originalText;
        }
      }

      // --- Helper Functions ---

      function updateProgress(percent, text) {
        progressBar.style.width = `${percent}%`;
        percentageText.textContent = `${percent}%`;
        if (text) statusText.textContent = text;
      }

      function showProgress(show) {
        if (show) {
          globalProgress.classList.remove("hidden");
        } else {
          globalProgress.classList.add("hidden");
        }
      }

      function enableDownload() {
        downloadBtn.disabled = false;
        downloadBtn.classList.remove(
          "bg-slate-200",
          "text-slate-400",
          "cursor-not-allowed",
        );
        downloadBtn.classList.add(
          "bg-blue-600",
          "text-white",
          "hover:bg-blue-700",
          "shadow-sm",
        );

        mobileDownloadBtn.disabled = false;
        mobileDownloadBtn.classList.remove(
          "hidden",
          "bg-slate-200",
          "text-slate-400",
          "cursor-not-allowed",
        );
        mobileDownloadBtn.classList.add(
          "bg-blue-600",
          "text-white",
          "hover:bg-blue-700",
        );
      }

      function disableDownload() {
        downloadBtn.disabled = true;
        downloadBtn.classList.add(
          "bg-slate-200",
          "text-slate-400",
          "cursor-not-allowed",
        );
        downloadBtn.classList.remove(
          "bg-blue-600",
          "text-white",
          "hover:bg-blue-700",
          "shadow-sm",
        );

        mobileDownloadBtn.disabled = true;
        mobileDownloadBtn.classList.add("hidden");
      }
    </script>
  </body>
</html>
