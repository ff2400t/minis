<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF OCR & Text Overlay Tool (Lit-HTML)</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- PDF.js -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"
    ></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    </script>

    <!-- Tesseract.js -->
    <script
      src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"
    ></script>

    <!-- jsPDF -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    ></script>

    <style>
      /* Custom scrollbar for text areas */
      .custom-scrollbar::-webkit-scrollbar {
        width: 8px;
      }
      .custom-scrollbar::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 4px;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
    </style>
  </head>
  <body class="bg-slate-50 text-slate-800 min-h-screen font-sans">
    <div id="app-root">
      <!-- Lit-HTML app will be rendered here -->
    </div>

    <script type="module">
      import {
        html,
        render,
      } from "https://cdn.jsdelivr.net/npm/lit-html@3.3.1/+esm";
      const { jsPDF } = window.jspdf;

      // --- GLOBAL STATE ---
      const state = {
        pdfDoc: null,
        processedPagesData: [], // { pageNum, imgData, width, height, words, text, status }
        isProcessing: false,
        processedJobCount: 0,
        scheduler: null,
        currentWorkerCount: 0,
        maxPage: 0,
        pagesToProcess: [],
        workerCount: 4,
        showResults: true,
        pageRangeInput: "",
        pageSelection: "all",
        pageRangeError: false,
        // Progress: { percent: number, text: string }
        progress: { percent: 0, text: "Ready to upload file." },
      };

      // --- STATE MANAGEMENT AND RENDER LOOP ---

      /**
       * Updates the state and triggers a re-render of the entire application.
       * @param {object} updates - Object containing state properties to update.
       */
      function updateState(updates) {
        Object.assign(state, updates);
        renderApp();
      }

      // --- CORE APPLICATION LOGIC ---

      /**
       * Parses a string like "1, 3-5, 8" into a sorted array of unique page numbers.
       */
      function parsePageRange(rangeStr, maxPage) {
        const pages = new Set();
        const parts = rangeStr.split(",").map((s) => s.trim()).filter(
          (s) => s.length > 0
        );

        for (const part of parts) {
          if (part.includes("-")) {
            const [startStr, endStr] = part.split("-").map((s) =>
              s.trim()
            );
            const start = parseInt(startStr, 10);
            const end = parseInt(endStr, 10);

            if (
              isNaN(start) || isNaN(end) || start < 1 ||
              end > maxPage || start > end
            ) {
              return null; // Invalid range or bounds
            }

            for (let i = start; i <= end; i++) {
              pages.add(i);
            }
          } else {
            const pageNum = parseInt(part, 10);
            if (isNaN(pageNum) || pageNum < 1 || pageNum > maxPage) {
              return null; // Invalid single page number
            }
            pages.add(pageNum);
          }
        }
        return Array.from(pages).sort((a, b) => a - b);
      }

      async function processFile(file) {
        if (!file || file.type !== "application/pdf") {
          console.error("Please upload a valid PDF file.");
          return;
        }

        if (state.isProcessing) return;

        // Reset state
        updateState({
          isProcessing: true,
          processedJobCount: 0,
          processedPagesData: [],
          pageRangeError: false,
          pdfDoc: null,
          progress: { percent: 0, text: "Loading PDF document..." },
        });

        try {
          const arrayBuffer = await file.arrayBuffer();
          const pdfDoc = await pdfjsLib.getDocument(arrayBuffer)
            .promise;
          const maxPage = pdfDoc.numPages;

          updateState({ pdfDoc, maxPage });

          // --- Determine Pages to Process ---
          let pagesToProcess = [];
          if (state.pageSelection === "all") {
            for (let i = 1; i <= maxPage; i++) {
              pagesToProcess.push(i);
            }
          } else {
            const parsedPages = parsePageRange(
              state.pageRangeInput,
              maxPage,
            );
            if (!parsedPages || parsedPages.length === 0) {
              updateState({
                pageRangeError: true,
                isProcessing: false,
              });
              throw new Error(
                "Invalid page selection. Please check your range/list.",
              );
            }
            pagesToProcess = parsedPages;
          }
          updateState({ pagesToProcess });

          const totalJobs = pagesToProcess.length;

          // --- SCHEDULER SETUP & WORKER CREATION ---
          const requestedWorkerCount = state.workerCount;

          if (!state.scheduler) {
            state.scheduler = Tesseract.createScheduler();
          }

          if (
            state.currentWorkerCount !== requestedWorkerCount ||
            state.currentWorkerCount === 0
          ) {
            updateState({
              progress: {
                percent: 0,
                text: `Terminating old workers...`,
              },
            });

            if (state.currentWorkerCount > 0) {
              await state.scheduler.terminate();
              state.scheduler = Tesseract.createScheduler();
            }

            updateState({
              progress: {
                percent: 0,
                text:
                  `Initializing ${requestedWorkerCount} OCR workers. This may take a moment...`,
              },
            });

            const workerPromises = [];
            for (let i = 0; i < requestedWorkerCount; i++) {
              workerPromises.push(Tesseract.createWorker("eng"));
            }

            const workers = await Promise.all(workerPromises);
            workers.forEach((worker) =>
              state.scheduler.addWorker(worker)
            );
            updateState({ currentWorkerCount: requestedWorkerCount });
          }

          // Initialize processedPagesData with statuses
          updateState({
            processedPagesData: pagesToProcess.map((pageNum) => ({
              pageNum,
              status: "Rendering & OCR Queued...",
              text: "",
            })),
          });

          // --- RENDER & QUEUE JOBS ---
          updateState({
            progress: {
              percent: 0,
              text: `Rendering pages for OCR...`,
            },
          });
          const pageJobPromises = [];

          for (let i = 0; i < totalJobs; i++) {
            const pageNum = pagesToProcess[i];
            pageJobPromises.push(processPage(pageNum, totalJobs));
          }

          updateState({
            progress: {
              percent: 0,
              text:
                `All pages rendered. Starting parallel OCR on ${state.currentWorkerCount} workers...`,
            },
          });

          await Promise.all(pageJobPromises);

          updateState({
            progress: {
              percent: 100,
              text: `Done! Processed ${totalJobs} pages.`,
            },
          });

          setTimeout(() => {
            if (!state.isProcessing) {
              updateState({
                progress: { percent: 0, text: "Processing complete." },
              });
            }
          }, 3000);
        } catch (err) {
          console.error(err);
          if (state.scheduler) {
            await state.scheduler.terminate();
            updateState({ scheduler: null, currentWorkerCount: 0 });
          }
          console.error("Error processing PDF: " + err.message);
          updateState({
            progress: { percent: 0, text: `Error: ${err.message}` },
          });
        } finally {
          updateState({ isProcessing: false });
          document.getElementById("fileInput").value = "";
        }
      }

      async function processPage(pageNum, totalJobs) {
        // Find the index of this page in the processedPagesData array
        const pageIndex = state.processedPagesData.findIndex((p) =>
          p.pageNum === pageNum
        );

        // 1. Setup Canvas for Rendering
        const page = await state.pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2.0 });

        // Create a temporary canvas for rendering/image data
        const renderCanvas = document.createElement("canvas");
        renderCanvas.height = viewport.height;
        renderCanvas.width = viewport.width;

        const renderContext = {
          canvasContext: renderCanvas.getContext("2d"),
          viewport: viewport,
        };

        // --- Update UI for Rendering Status ---
        state.processedPagesData[pageIndex].status = "Rendering...";
        renderApp();

        await page.render(renderContext).promise;
        const imgData = renderCanvas.toDataURL("image/jpeg", 0.8);

        // 2. Display Image on UI Canvas (if visible)
        if (state.showResults) {
          // Find the specific canvas element for this page and draw to it
          const uiCanvas = document.getElementById(`canvas-${pageNum}`);
          if (uiCanvas) {
            uiCanvas.height = viewport.height / 2; // Resize for display
            uiCanvas.width = viewport.width / 2;
            const ctx = uiCanvas.getContext("2d");
            ctx.drawImage(
              renderCanvas,
              0,
              0,
              uiCanvas.width,
              uiCanvas.height,
            );
          }
        }

        // 3. Perform OCR
        state.processedPagesData[pageIndex].status =
          "OCR Processing...";
        renderApp();

        const result = await state.scheduler.addJob(
          "recognize",
          imgData,
        );
        const { text, words } = result.data;

        // 4. Store and Update UI
        state.processedPagesData[pageIndex] = {
          pageNum,
          imgData: imgData,
          width: viewport.width,
          height: viewport.height,
          words: words,
          text: text,
          status: "Completed",
        };

        state.processedJobCount++;
        updateState({
          processedJobCount: state.processedJobCount,
          processedPagesData: [...state.processedPagesData], // Trigger re-render
          progress: {
            percent: Math.round(
              (state.processedJobCount / totalJobs) * 100,
            ),
            text:
              `OCR complete for page ${pageNum} (${state.processedJobCount} of ${totalJobs})...`,
          },
        });
      }

      async function generateSearchablePDF() {
        if (state.processedPagesData.length === 0) return;

        // Sort data by page number to ensure PDF pages are in the correct order
        state.processedPagesData.sort((a, b) => a.pageNum - b.pageNum);

        updateState({
          progress: { percent: 100, text: "Generating PDF..." },
        });

        try {
          const firstPage = state.processedPagesData[0];
          const doc = new jsPDF({
            orientation: "portrait",
            unit: "px",
            format: [firstPage.width, firstPage.height],
          });

          state.processedPagesData.forEach((pageData, index) => {
            if (index > 0) {
              doc.addPage([pageData.width, pageData.height]);
            }

            const width = pageData.width;
            const height = pageData.height;

            // 1. Add the original image as background
            doc.addImage(pageData.imgData, "JPEG", 0, 0, width, height);

            // 2. Add invisible text overlay
            doc.setFontSize(12);
            doc.setTextColor(255, 255, 255);
            doc.internal.write("3 Tr"); // Text Rendering Mode 3 (Invisible)

            pageData.words.forEach((word) => {
              const { text, bbox } = word;
              const h = bbox.y1 - bbox.y0;
              const fontSize = h * 0.9;
              doc.setFontSize(fontSize);
              doc.text(text, bbox.x0, bbox.y1, { baseline: "bottom" });
            });
          });

          doc.save("ocr-searchable-result.pdf");
          updateState({
            progress: {
              percent: 100,
              text: "PDF downloaded successfully!",
            },
          });
        } catch (err) {
          console.error(err);
          updateState({
            progress: { percent: 100, text: "Error creating PDF." },
          });
        }
      }

      // --- UI TEMPLATES (Lit-HTML) ---

      const headerTemplate = () =>
        html`
          <header class="bg-white border-b border-slate-200 sticky top-0 z-50">
            <div
              class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex items-center justify-between"
            >
              <div class="flex items-center gap-2">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-8 w-8 text-blue-600"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                  />
                </svg>
                <h1 class="text-xl font-bold text-slate-900">
                  OCR Overlay Tool (Lit-HTML)
                </h1>
              </div>
              <div class="flex gap-3">
                <button
                  @click="${generateSearchablePDF}"
                  ?disabled="${!state.pdfDoc || state.isProcessing}"
                  class="
                    hidden sm:flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-colors
                    ${!state.pdfDoc || state.isProcessing
                      ? "bg-slate-200 text-slate-400 cursor-not-allowed"
                      : "bg-blue-600 text-white hover:bg-blue-700 shadow-sm"}
                  "
                >
                  <span>Download PDF</span>
                </button>
              </div>
            </div>
          </header>
        `;

      const uploadTemplate = () =>
        html`
          <div id="uploadSection" class="mb-8">
            <label
              for="fileInput"
              id="dropZone"
              class="
                flex flex-col items-center justify-center w-full h-32 border-2 border-slate-300 border-dashed rounded-lg cursor-pointer bg-white hover:bg-slate-50 transition-all
                ${state.isProcessing
                  ? "opacity-50 cursor-not-allowed"
                  : ""}
              "
            >
              <div
                class="flex flex-col items-center justify-center pt-5 pb-6 pointer-events-none"
              >
                <svg
                  class="w-8 h-8 mb-3 text-slate-400"
                  aria-hidden="true"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 20 16"
                >
                  <path
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"
                  />
                </svg>
                <p class="text-sm text-slate-500">
                  <span class="font-semibold">Click to upload PDF</span> or drag
                  and drop
                </p>
                <p class="text-xs text-slate-400 mt-1">
                  PDF files only (Processing happens locally in your browser)
                </p>
              </div>
              <input
                id="fileInput"
                type="file"
                accept="application/pdf"
                class="hidden"
                @change="${(e) => processFile(e.target.files[0])}"
                ?disabled="${state.isProcessing}"
              />
            </label>
          </div>
        `;

      const optionsTemplate = () =>
        html`
          <div
            class="bg-white p-6 rounded-xl shadow-sm border border-slate-200 mb-8 ${state
                .pdfDoc
              ? ""
              : "hidden"}"
          >
            <h2 class="text-lg font-semibold text-slate-700 mb-4">
              Processing Options
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- 1. Page Selection -->
              <div>
                <label class="block text-sm font-medium text-slate-700 mb-2"
                >Pages to OCR</label>
                <div class="flex items-center gap-4">
                  <div class="flex items-center">
                    <input
                      id="allPagesRadio"
                      name="pageSelection"
                      type="radio"
                      .checked="${state.pageSelection === "all"}"
                      @change="${() =>
                        updateState({
                          pageSelection: "all",
                          pageRangeError: false,
                        })}"
                      class="h-4 w-4 text-blue-600 border-slate-300 focus:ring-blue-500"
                      value="all"
                    >
                    <label
                      for="allPagesRadio"
                      class="ml-2 block text-sm text-slate-900"
                    >All Pages (${state.maxPage})</label>
                  </div>
                  <div class="flex items-center">
                    <input
                      id="selectPagesRadio"
                      name="pageSelection"
                      type="radio"
                      .checked="${state.pageSelection === "select"}"
                      @change="${() =>
                        updateState({
                          pageSelection: "select",
                          pageRangeError: false,
                        })}"
                      class="h-4 w-4 text-blue-600 border-slate-300 focus:ring-blue-500"
                      value="select"
                    >
                    <label
                      for="selectPagesRadio"
                      class="ml-2 block text-sm text-slate-900"
                    >Select Range/List</label>
                  </div>
                </div>
                <input
                  id="pageRangeInput"
                  type="text"
                  .disabled="${state.pageSelection === "all"}"
                  .value="${state.pageRangeInput}"
                  @input="${(e) =>
                    updateState({
                      pageRangeInput: e.target.value,
                      pageRangeError: false,
                    })}"
                  placeholder="e.g., 1, 3-5, 8 (Max: ${state.maxPage})"
                  class="
                    mt-2 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-slate-50 disabled:text-slate-400 text-sm p-2
                    ${state.pageRangeError
                      ? "border-red-500 ring-red-500"
                      : ""}
                  "
                >
                <p class="mt-1 text-xs text-red-600 ${state
                    .pageRangeError
                  ? ""
                  : "hidden"}">
                  Invalid page range format or page number out of bounds.
                </p>
              </div>

              <!-- 2. Worker Count -->
              <div class="border-l pl-6 border-slate-100">
                <label
                  for="workerCountInput"
                  class="block text-sm font-medium text-slate-700 mb-2"
                >OCR Workers (Threads)</label>
                <input
                  id="workerCountInput"
                  type="number"
                  .value="${state.workerCount}"
                  @change="${(e) =>
                    updateState({
                      workerCount: parseInt(e.target.value, 10),
                    })}"
                  min="1"
                  max="8"
                  class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm p-2"
                  title="The number of parallel workers Tesseract will use for OCR. Recommended: 2-4"
                >
                <p class="text-xs text-slate-400 mt-1">
                  More workers = faster processing, higher memory use.
                </p>
              </div>

              <!-- 3. Toggle Display -->
              <div class="border-l pl-6 border-slate-100">
                <label
                  for="showResultsToggle"
                  class="relative inline-flex items-center cursor-pointer mb-2"
                >
                  <input
                    type="checkbox"
                    id="showResultsToggle"
                    .checked="${state.showResults}"
                    @change="${(e) =>
                      updateState({ showResults: e.target.checked })}"
                    class="sr-only peer"
                  >
                  <div
                    class="w-11 h-6 bg-slate-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-slate-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"
                  >
                  </div>
                  <span class="ml-3 text-sm font-medium text-slate-700"
                  >Show Page Results</span>
                </label>
                <p class="text-xs text-slate-400 mt-1">
                  Hide to speed up processing on very large PDFs.
                </p>
              </div>
            </div>
          </div>
        `;

      const progressTemplate = () =>
        html`
          <div id="globalProgress" class="mb-8 ${state.isProcessing
            ? ""
            : "hidden"}">
            <div class="flex justify-between mb-1">
              <span id="statusText" class="text-sm font-medium text-blue-700"
              >${state.progress.text}</span>
              <span id="percentageText" class="text-sm font-medium text-blue-700"
              >${state.progress.percent}%</span>
            </div>
            <div class="w-full bg-slate-200 rounded-full h-2.5">
              <div
                id="progressBar"
                class="bg-blue-600 h-2.5 rounded-full transition-all duration-300"
                style="width: ${state.progress.percent}%"
              >
              </div>
            </div>
          </div>
        `;

      const pageTemplate = (page) => {
        const statusColor = page.status === "Completed"
          ? "bg-green-500"
          : "bg-blue-500 animate-pulse";
        const statusTextClass = page.status === "Completed"
          ? "text-green-600"
          : "text-blue-600";

        const copyText = (e) => {
          const textarea = e.target.closest(".p-4.flex.flex-col")
            .querySelector("textarea");
          textarea.select();
          document.execCommand("copy");
          const originalText = e.target.textContent;
          e.target.textContent = "Copied!";
          setTimeout(() => e.target.textContent = originalText, 2000);
        };

        // Lit-HTML doesn't directly support <canvas> drawing on render,
        // so we rely on the logic in processPage to draw when the element becomes available.
        return html`
          <div
            class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden"
          >
            <div
              class="border-b border-slate-100 bg-slate-50 px-4 py-3 flex justify-between items-center"
            >
              <h3 class="font-semibold text-slate-700">Page ${page
                .pageNum}</h3>
              <div
                class="status-indicator flex items-center gap-2 text-xs font-medium text-slate-500"
              >
                <span class="status-dot w-2 h-2 rounded-full ${statusColor}"></span>
                <span class="status-text ${statusTextClass}">${page
                  .status}</span>
              </div>
            </div>
            <div
              class="grid grid-cols-1 md:grid-cols-2 divide-y md:divide-y-0 md:divide-x divide-slate-100"
            >
              <!-- Image Column -->
              <div
                class="p-4 bg-slate-50/50 flex items-start justify-center overflow-auto max-h-[600px] custom-scrollbar"
              >
                <!-- Canvas ID ensures we can find it in processPage for drawing the rendered image -->
                <canvas
                  id="canvas-${page.pageNum}"
                  class="pdf-canvas shadow-lg max-w-full h-auto"
                ></canvas>
              </div>
              <!-- Text Column -->
              <div class="p-4 flex flex-col h-[600px]">
                <div class="flex justify-between items-center mb-2">
                  <span
                    class="text-xs font-semibold text-slate-400 uppercase tracking-wider"
                  >Extracted Text</span>
                  <button
                    @click="${copyText}"
                    class="copy-btn text-xs text-blue-600 hover:text-blue-800 font-medium"
                  >
                    Copy Text
                  </button>
                </div>
                <textarea
                  class="extracted-text w-full flex-1 p-3 text-sm text-slate-700 border border-slate-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none resize-none custom-scrollbar font-mono leading-relaxed bg-white"
                  readonly
                  placeholder="Text will appear here after processing..."
                >${page.text}</textarea>
              </div>
            </div>
          </div>
        `;
      };

      const resultsTemplate = () =>
        html`
          <!-- Mobile Download Button -->
          <button
            @click="${generateSearchablePDF}"
            ?disabled="${!state.pdfDoc || state.isProcessing}"
            class="
              w-full mb-6 sm:hidden flex justify-center items-center gap-2 px-4 py-3 rounded-lg font-medium transition-colors
              ${!state.pdfDoc || state.isProcessing
                ? "bg-slate-200 text-slate-400 cursor-not-allowed"
                : "bg-blue-600 text-white hover:bg-blue-700"}
            "
          >
            Download PDF
          </button>

          <div class="space-y-12 ${state.showResults ? "" : "hidden"}">
            ${state.processedPagesData.map(pageTemplate)}
          </div>
        `;

      // --- MAIN APPLICATION TEMPLATE ---

      const AppTemplate = () =>
        html`
          ${headerTemplate()}
          <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            ${uploadTemplate()} ${optionsTemplate()} ${progressTemplate()} ${state
                .processedPagesData.length > 0
              ? resultsTemplate()
              : ""}
          </main>
        `;

      // Initial Render
      function renderApp() {
        render(AppTemplate(), document.getElementById("app-root"));
      }

      document.addEventListener("DOMContentLoaded", renderApp);
    </script>
  </body>
</html>
