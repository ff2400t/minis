<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF/Image OCR & Text Overlay Tool</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"
    ></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    </script>

    <!-- Tesseract.js -->
    <script
      src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"
    ></script>

    <!-- jsPDF (for image-based output) -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    ></script>

    <style>
      /* Custom scrollbar for text areas */
      .custom-scrollbar::-webkit-scrollbar {
        width: 8px;
      }
      .custom-scrollbar::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 4px;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
    </style>
  </head>
  <body class="bg-slate-50 text-slate-800 min-h-screen font-sans">
    <!-- Main Haunted Web Component -->
    <ocr-app></ocr-app>

    <script type="module">
      // Load haunted and its dependencies from CDN
      import { html, render } from "https://unpkg.com/lit-html?module";
      // Import useRef explicitly
      import {
        component,
        useCallback,
        useEffect,
        useMemo,
        useRef,
        useState,
      } from "https://unpkg.com/haunted?module";
      // Access jsPDF from the global window object
      const { jsPDF } = window.jspdf;

      // --- GLOBAL UTILITIES ---

      /**
       * Parses a string like "1, 3-5, 8" into a sorted array of unique page numbers.
       */
      function parsePageRange(rangeStr, maxPage) {
        const pages = new Set();
        const parts = rangeStr.split(",").map((s) => s.trim()).filter(
          (s) => s.length > 0,
        );

        for (const part of parts) {
          if (part.includes("-")) {
            const [startStr, endStr] = part.split("-").map((s) =>
              s.trim()
            );
            const start = parseInt(startStr, 10);
            const end = parseInt(endStr, 10);

            if (
              isNaN(start) || isNaN(end) || start < 1 ||
              end > maxPage || start > end
            ) {
              return null; // Invalid range or bounds
            }

            for (let i = start; i <= end; i++) {
              pages.add(i);
            }
          } else {
            const pageNum = parseInt(part, 10);
            if (isNaN(pageNum) || pageNum < 1 || pageNum > maxPage) {
              return null; // Invalid single page number
            }
            pages.add(pageNum);
          }
        }
        return Array.from(pages).sort((a, b) => a - b);
      }

      // --- HOOK: useAppState for centralized logic ---

      function useAppState() {
        const [appMode, setAppMode] = useState("IDLE"); // 'IDLE', 'LOADED', 'PROCESSING', 'COMPLETED'
        const [pdfDoc, setPdfDoc] = useState(null);
        const [sourceImageData, setSourceImageData] = useState(null); // Persist source image data
        const [processedPagesData, setProcessedPagesData] = useState(
          [],
        );
        const [processedJobCount, setProcessedJobCount] = useState(0);
        const [scheduler, setScheduler] = useState(null);
        const [currentWorkerCount, setCurrentWorkerCount] = useState(0);
        const [maxPage, setMaxPage] = useState(0);
        const [pagesToProcess, setPagesToProcess] = useState([]);
        const [workerCount, setWorkerCount] = useState(4);
        const [showResults, setShowResults] = useState(true);
        const [pageRangeInput, setPageRangeInput] = useState("");
        const [pageSelection, setPageSelection] = useState("all");
        const [pageRangeError, setPageRangeError] = useState(false);
        const [progress, setProgress] = useState({
          percent: 0,
          text: "Ready to upload file.",
        });
        const [inputType, setInputType] = useState("NONE"); // 'NONE', 'PDF', 'IMAGE'

        // Single shared canvas for rendering PDF pages to avoid memory leaks
        const renderCanvasRef = useRef(
          document.createElement("canvas"),
        );

        const isProcessing = appMode === "PROCESSING";

        // --- Handlers ---

        const handleFileSelect = useCallback(async (file) => {
          if (!file || isProcessing) return;

          const mimeType = file.type;
          const isPdf = mimeType === "application/pdf";
          const isImage = mimeType.startsWith("image/");

          if (!isPdf && !isImage) return;

          // Reset state
          setAppMode("PROCESSING");
          setInputType(isPdf ? "PDF" : "IMAGE");
          setProcessedJobCount(0);
          setProcessedPagesData([]);
          setSourceImageData(null);
          setPageRangeError(false);
          setPdfDoc(null);
          setMaxPage(0);
          setProgress({
            percent: 0,
            text: `Loading ${isPdf ? "PDF" : "Image"} file...`,
          });

          try {
            if (isPdf) {
              // PDF Loading Logic
              const arrayBuffer = await file.arrayBuffer();
              const doc = await pdfjsLib.getDocument(arrayBuffer)
                .promise;
              const numPages = doc.numPages;

              setPdfDoc(doc);
              setMaxPage(numPages);
              setAppMode("LOADED");
              setProgress({
                percent: 0,
                text: `PDF loaded. ${numPages} page(s) available.`,
              });
            } else if (isImage) {
              // Image Loading Logic
              const arrayBuffer = await file.arrayBuffer();
              const blob = new Blob([arrayBuffer], { type: mimeType });
              const imgData = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              });

              setSourceImageData(imgData);

              // Set preview immediately
              setProcessedPagesData([{
                pageNum: 1,
                imgData: imgData,
                status: "Image loaded. Ready for OCR.",
                text: "",
                width: 0,
                height: 0,
              }]);
              setMaxPage(1);
              setAppMode("LOADED");
              setProgress({
                percent: 0,
                text: `Image loaded. Ready to process 1 page.`,
              });
            }
          } catch (err) {
            console.error("Error loading file:", err);
            setAppMode("IDLE");
            setProgress({
              percent: 0,
              text: `Error loading file: ${err.message}`,
            });
          }
        }, [isProcessing]);

        const startProcessing = useCallback(async () => {
          if (appMode !== "LOADED") return;

          setAppMode("PROCESSING");
          setProcessedJobCount(0);
          setPageRangeError(false);
          setProgress({
            percent: 0,
            text: "Preparing processing job...",
          });

          try {
            // 1. Determine Pages to Process
            let selectedPages = [];
            if (inputType === "IMAGE") {
              selectedPages = [1];
            } else if (pageSelection === "all") {
              for (let i = 1; i <= maxPage; i++) {
                selectedPages.push(i);
              }
            } else {
              const parsedPages = parsePageRange(
                pageRangeInput,
                maxPage,
              );
              if (!parsedPages || parsedPages.length === 0) {
                setPageRangeError(true);
                setAppMode("LOADED");
                throw new Error("Invalid page selection.");
              }
              selectedPages = parsedPages;
            }
            setPagesToProcess(selectedPages);
            const totalJobs = selectedPages.length;

            // 2. Initialize State with Placeholders
            // This ensures the UI has cards to show immediately
            const initialData = selectedPages.map((pageNum) => ({
              pageNum,
              status: "Pending...",
              text: "",
              words: [],
              // If it's image mode, we technically have data, but we'll re-process flow for consistency
              imgData: inputType === "IMAGE" ? sourceImageData : null,
              width: 0,
              height: 0,
            }));
            setProcessedPagesData(initialData);

            // 3. Scheduler Setup
            let schedulerInstance = scheduler;
            const requestedWorkerCount = workerCount;

            if (
              !schedulerInstance ||
              currentWorkerCount !== requestedWorkerCount
            ) {
              if (schedulerInstance) {
                setProgress({
                  percent: 0,
                  text: `Terminating old workers...`,
                });
                await schedulerInstance.terminate();
                schedulerInstance = null;
              }

              setProgress({
                percent: 0,
                text:
                  `Initializing ${requestedWorkerCount} OCR workers...`,
              });
              schedulerInstance = Tesseract.createScheduler();
              const workerPromises = [];
              for (let i = 0; i < requestedWorkerCount; i++) {
                workerPromises.push(Tesseract.createWorker("eng"));
              }

              const workers = await Promise.all(workerPromises);
              workers.forEach((worker) =>
                schedulerInstance.addWorker(worker)
              );
              setScheduler(schedulerInstance);
              setCurrentWorkerCount(requestedWorkerCount);
            }

            // 4. Sequential Rendering & Parallel OCR
            // We render pages one by one to reuse the canvas, but fire OCR jobs off to run in parallel.

            const ocrPromises = [];
            const canvas = renderCanvasRef.current; // Reuse this canvas

            for (const pageNum of selectedPages) {
              let pageImgData, width, height;

              // A. Update Status to Rendering
              setProcessedPagesData((prev) =>
                prev.map((p) =>
                  p.pageNum === pageNum
                    ? { ...p, status: "Rendering..." }
                    : p
                )
              );

              // B. Render
              if (inputType === "PDF") {
                const page = await pdfDoc.getPage(pageNum);
                // Scale 2.0 for OCR quality
                const viewport = page.getViewport({ scale: 2.0 });

                canvas.width = viewport.width;
                canvas.height = viewport.height;

                const ctx = canvas.getContext("2d");
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                await page.render({ canvasContext: ctx, viewport })
                  .promise;

                // Capture data immediately
                pageImgData = canvas.toDataURL("image/jpeg", 0.8);
                width = viewport.width;
                height = viewport.height;
              } else {
                // Image Mode
                pageImgData = sourceImageData;
                const img = new Image();
                await new Promise((r) => {
                  img.onload = r;
                  img.src = pageImgData;
                });
                width = img.width;
                height = img.height;
              }

              // C. Update State with Image Data (Saved to hook memory now)
              // This ensures that even if we reuse the canvas, we have a copy of the data.
              setProcessedPagesData((prev) =>
                prev.map((p) =>
                  p.pageNum === pageNum
                    ? {
                      ...p,
                      imgData: pageImgData,
                      width,
                      height,
                      status: "OCR Processing...",
                    }
                    : p
                )
              );

              // D. Schedule OCR Job
              const job = schedulerInstance.addJob(
                "recognize",
                pageImgData,
              )
                .then((result) => {
                  const { text, words } = result.data;
                  // Update state with result
                  setProcessedPagesData((prev) =>
                    prev.map((p) =>
                      p.pageNum === pageNum
                        ? { ...p, text, words, status: "Completed" }
                        : p
                    )
                  );
                  setProcessedJobCount((prev) => {
                    const newCount = prev + 1;
                    setProgress({
                      percent: Math.round((newCount / totalJobs) * 100),
                      text:
                        `OCR processed page ${pageNum} (${newCount} of ${totalJobs}).`,
                    });
                    return newCount;
                  });
                });

              ocrPromises.push(job);

              // E. Small delay to prevent UI freezing between heavy renders
              await new Promise((r) => setTimeout(r, 20));
            }

            // 5. Wait for all OCR to finish
            await Promise.all(ocrPromises);

            setAppMode("COMPLETED");
            setProgress({
              percent: 100,
              text: `Done! Processed ${totalJobs} page(s).`,
            });
          } catch (err) {
            console.error("OCR Process Error:", err);
            setAppMode("LOADED");
            setProgress({
              percent: 0,
              text: `Error during processing: ${err.message}`,
            });
          }
        }, [
          appMode,
          pdfDoc,
          sourceImageData,
          pageSelection,
          maxPage,
          pageRangeInput,
          workerCount,
          scheduler,
          currentWorkerCount,
          inputType,
        ]);

        // --- PDF OUTPUT FUNCTION ---

        const generateFinalPDF = useCallback(async () => {
          if (
            appMode !== "COMPLETED" || processedPagesData.length === 0
          ) return;

          // Sort data by page number
          const sortedData = [...processedPagesData].sort((a, b) =>
            a.pageNum - b.pageNum
          );

          setProgress({
            percent: 100,
            text: "Generating Searchable PDF file...",
          });

          try {
            const firstPage = sortedData[0];
            const doc = new jsPDF({
              orientation: firstPage.width > firstPage.height
                ? "landscape"
                : "portrait",
              unit: "px",
              format: [firstPage.width, firstPage.height],
            });

            sortedData.forEach((pageData, index) => {
              if (index > 0) {
                doc.addPage([pageData.width, pageData.height]);
              }

              const width = pageData.width;
              const height = pageData.height;

              // 1. Add the original image as background
              if (
                pageData.imgData &&
                typeof pageData.imgData === "string" &&
                pageData.imgData.startsWith("data:")
              ) {
                doc.addImage(
                  pageData.imgData,
                  "JPEG",
                  0,
                  0,
                  width,
                  height,
                );
              } else {
                console.warn(
                  `Skipping image add for page ${pageData.pageNum} due to missing data.`,
                );
              }

              // 2. Add invisible text overlay
              doc.setFontSize(12);
              doc.setTextColor(255, 255, 255); // White text
              doc.internal.write("3 Tr"); // Text Rendering Mode 3 (Invisible)

              if (pageData.words) {
                pageData.words.forEach((word) => {
                  const { text, bbox } = word;
                  const h = bbox.y1 - bbox.y0;
                  const fontSize = h * 0.9;
                  doc.setFontSize(fontSize);
                  doc.text(text, bbox.x0, bbox.y1, {
                    baseline: "bottom",
                  });
                });
              }
            });

            const fileName = inputType === "IMAGE"
              ? "ocr-image-to-pdf.pdf"
              : "ocr-searchable-pdf.pdf";
            doc.save(fileName);
            setProgress({
              percent: 100,
              text: "PDF downloaded successfully!",
            });
          } catch (err) {
            console.error(err);
            setProgress({ percent: 100, text: "Error creating PDF." });
          }
        }, [appMode, processedPagesData, inputType]);

        return {
          appMode,
          setAppMode,
          processedPagesData,
          progress,
          isProcessing,
          inputType,
          maxPage,
          setMaxPage,
          workerCount,
          setWorkerCount,
          showResults,
          setShowResults,
          pageRangeInput,
          setPageRangeInput,
          pageSelection,
          setPageSelection,
          pageRangeError,
          setPageRangeError,
          handleFileSelect,
          startProcessing,
          generateFinalPDF,
        };
      }

      // --- DROP ZONE WEB COMPONENT ---

      function DropZone() {
        // Get properties passed to the custom element
        const { disabled } = this;

        // Handle file selection from the input element
        const handleFileChange = (e) => {
          const file = e.target.files?.[0];
          if (file && !disabled) {
            // Dispatch custom event with the file object
            this.dispatchEvent(
              new CustomEvent("file-selected", { detail: file }),
            );
          }
          // Clear input value so selecting the same file triggers change again
          e.target.value = null;
        };

        // Drag and Drop Handlers
        const handleDragOver = (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (!disabled) {
            e.currentTarget.classList.add(
              "border-blue-500",
              "ring-2",
              "ring-blue-200",
              "scale-[1.02]",
            );
          }
        };

        const handleDragLeave = (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.currentTarget.classList.remove(
            "border-blue-500",
            "ring-2",
            "ring-blue-200",
            "scale-[1.02]",
          );
        };

        const handleDrop = (e) => {
          e.preventDefault();
          e.stopPropagation();
          handleDragLeave(e); // Remove highlight

          if (disabled) return;

          const file = e.dataTransfer.files?.[0];
          if (file) {
            // Dispatch custom event with the dropped file object
            this.dispatchEvent(
              new CustomEvent("file-selected", { detail: file }),
            );
          }
        };

        return html`
          <div id="uploadSection" class="mb-8">
            <label
              for="fileInput"
              id="dropZoneLabel"
              class="
                flex flex-col items-center justify-center w-full h-32 border-2 border-slate-300 border-dashed rounded-xl cursor-pointer bg-white hover:bg-slate-50 transition-all duration-150
                ${disabled
                  ? "opacity-50 cursor-not-allowed"
                  : "hover:border-blue-400"}
              "
              @dragover="${handleDragOver}"
              @dragleave="${handleDragLeave}"
              @drop="${handleDrop}"
            >
              <div
                class="flex flex-col items-center justify-center pt-5 pb-6 pointer-events-none"
              >
                <svg
                  class="w-8 h-8 mb-3 text-slate-400"
                  aria-hidden="true"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 20 16"
                >
                  <path
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"
                  />
                </svg>
                <p class="text-sm text-slate-500">
                  <span class="font-semibold">Click to upload PDF or Image</span>
                  or drag and drop
                </p>
                <p class="text-xs text-slate-400 mt-1">
                  PDF, JPG, PNG files only
                </p>
              </div>
              <input
                id="fileInput"
                type="file"
                accept="application/pdf,image/jpeg,image/png"
                class="hidden"
                @change="${handleFileChange}"
                ?disabled="${disabled}"
              />
            </label>
          </div>
        `;
      }
      // Register the new custom element. 'disabled' property allows control from parent.
      customElements.define(
        "drop-zone",
        component(DropZone, {
          properties: { disabled: Boolean },
          useShadowDOM: false,
        }),
      );

      // --- MAIN APP COMPONENT ---

      function App() {
        // Destructure all values and handlers from the custom hook
        const {
          appMode,
          processedPagesData,
          progress,
          isProcessing,
          inputType,
          maxPage,
          workerCount,
          setWorkerCount,
          showResults,
          setShowResults,
          pageRangeInput,
          setPageRangeInput,
          pageSelection,
          setPageSelection,
          pageRangeError,
          setPageRangeError,
          handleFileSelect,
          startProcessing,
          generateFinalPDF,
        } = useAppState();

        return html`
          ${Header()}
          <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <!-- Updated to use the new <drop-zone> component -->
            <drop-zone
              .disabled="${isProcessing}"
              @file-selected="${(e) => handleFileSelect(e.detail)}"
            ></drop-zone>

            ${OptionsPanel({
              appMode,
              isProcessing,
              maxPage,
              workerCount,
              setWorkerCount,
              showResults,
              setShowResults,
              pageRangeInput,
              setPageRangeInput,
              pageSelection,
              setPageSelection,
              pageRangeError,
              setPageRangeError,
              inputType,
            })} ${MainActionButton({
              appMode,
              startProcessing,
              generateFinalPDF,
              inputType,
            })} ${ProgressBar({ appMode, progress })} ${ResultsArea({
              processedPagesData,
              showResults,
              appMode,
            })}
          </main>
        `;
      }

      const Header = () =>
        html`
          <header class="bg-white border-b border-slate-200 sticky top-0 z-50">
            <div
              class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex items-center justify-center"
            >
              <div class="flex items-center gap-2">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-8 w-8 text-blue-600"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                  />
                </svg>
                <h1 class="text-xl font-bold text-slate-900">
                  OCR Overlay Tool (PDF & Images)
                </h1>
              </div>
            </div>
          </header>
        `;

      const OptionsPanel = ({
        appMode,
        isProcessing,
        maxPage,
        workerCount,
        setWorkerCount,
        showResults,
        setShowResults,
        pageRangeInput,
        setPageRangeInput,
        pageSelection,
        setPageSelection,
        pageRangeError,
        setPageRangeError,
        inputType,
      }) => {
        const isVisible = appMode !== "IDLE";

        return html`
          <div
            class="bg-white p-6 rounded-xl shadow-sm border border-slate-200 mb-8 ${isVisible
              ? ""
              : "hidden"}"
          >
            <h2 class="text-lg font-semibold text-slate-700 mb-4">
              Processing Options
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- 1. Page Selection (Hidden for Image Input) -->
              <div class="${inputType === "IMAGE"
                ? "hidden"
                : "block"}">
                <label class="block text-sm font-medium text-slate-700 mb-2"
                >Pages to OCR</label>
                <div class="flex items-center gap-4">
                  <div class="flex items-center">
                    <input
                      id="allPagesRadio"
                      name="pageSelection"
                      type="radio"
                      .checked="${pageSelection === "all"}"
                      @change="${() => {
                        setPageSelection("all");
                        setPageRangeError(false);
                      }}"
                      class="h-4 w-4 text-blue-600 border-slate-300 focus:ring-blue-500"
                      value="all"
                      ?disabled="${isProcessing}"
                    >
                    <label
                      for="allPagesRadio"
                      class="ml-2 block text-sm text-slate-900"
                    >All Pages (${maxPage})</label>
                  </div>
                  <div class="flex items-center">
                    <input
                      id="selectPagesRadio"
                      name="pageSelection"
                      type="radio"
                      .checked="${pageSelection === "select"}"
                      @change="${() => {
                        setPageSelection("select");
                        setPageRangeError(false);
                      }}"
                      class="h-4 w-4 text-blue-600 border-slate-300 focus:ring-blue-500"
                      value="select"
                      ?disabled="${isProcessing}"
                    >
                    <label
                      for="selectPagesRadio"
                      class="ml-2 block text-sm text-slate-900"
                    >Select Range/List</label>
                  </div>
                </div>
                <input
                  id="pageRangeInput"
                  type="text"
                  .disabled="${pageSelection === "all" || isProcessing}"
                  .value="${pageRangeInput}"
                  @input="${(e) => {
                    setPageRangeInput(e.target.value);
                    setPageRangeError(false);
                  }}"
                  placeholder="e.g., 1, 3-5, 8 (Max: ${maxPage})"
                  class="
                    mt-2 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-slate-50 disabled:text-slate-400 text-sm p-2
                    ${pageRangeError
                      ? "border-red-500 ring-red-500"
                      : ""}
                  "
                >
                <p class="mt-1 text-xs text-red-600 ${pageRangeError
                  ? ""
                  : "hidden"}">
                  Invalid page range format or page number out of bounds.
                </p>
              </div>

              <!-- Page Selection for Images (Filler) -->
              <div class="${inputType === "IMAGE"
                ? "block"
                : "hidden"}">
                <label class="block text-sm font-medium text-slate-700 mb-2"
                >Pages to OCR</label>
                <p
                  class="mt-2 block w-full rounded-md border border-slate-200 bg-slate-500/5 text-slate-600 text-sm p-2"
                >
                  Single image processed as Page 1.
                </p>
              </div>

              <!-- 2. Worker Count -->
              <div class="pl-6 border-slate-100 ${inputType !== "NONE"
                ? "border-l"
                : ""}">
                <label
                  for="workerCountInput"
                  class="block text-sm font-medium text-slate-700 mb-2"
                >OCR Workers (Threads)</label>
                <input
                  id="workerCountInput"
                  type="number"
                  .value="${workerCount}"
                  @change="${(e) =>
                    setWorkerCount(parseInt(e.target.value, 10))}"
                  min="1"
                  max="8"
                  class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm p-2"
                  title="The number of parallel workers Tesseract will use for OCR. Recommended: 2-4"
                  ?disabled="${isProcessing}"
                >
                <p class="text-xs text-slate-400 mt-1">
                  More workers = faster processing, higher memory use.
                </p>
              </div>

              <!-- 3. Show Results Toggle (Always visible when loaded) -->
              <div class="pl-6 border-l border-slate-100">
                <label
                  for="showResultsToggle"
                  class="relative inline-flex items-center cursor-pointer mb-2"
                >
                  <input
                    type="checkbox"
                    id="showResultsToggle"
                    .checked="${showResults}"
                    @change="${(e) => setShowResults(e.target.checked)}"
                    class="sr-only peer"
                  >
                  <div
                    class="w-11 h-6 bg-slate-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-slate-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"
                  >
                  </div>
                  <span class="ml-3 text-sm font-medium text-slate-700"
                  >Show Page Results</span>
                </label>
                <p class="text-xs text-slate-400 mt-1">
                  Hide to speed up processing on very large documents.
                </p>
              </div>
            </div>
          </div>
        `;
      };

      const MainActionButton = (
        { appMode, startProcessing, generateFinalPDF, inputType },
      ) => {
        let text = "";
        let action = () => {};
        let disabled = true;
        let className =
          "bg-slate-200 text-slate-400 cursor-not-allowed";

        if (appMode === "LOADED") {
          text = "Start Processing";
          action = startProcessing;
          disabled = false;
          className =
            "bg-blue-600 text-white hover:bg-blue-700 shadow-lg";
        } else if (appMode === "PROCESSING") {
          text = "Processing...";
          disabled = true;
          className = "bg-slate-400 text-white cursor-wait";
        } else if (appMode === "COMPLETED") {
          // Now only one output mode: New Searchable PDF
          text = inputType === "IMAGE"
            ? "Download Searchable PDF"
            : "Download Searchable PDF";
          action = generateFinalPDF;
          disabled = false;
          className =
            "bg-green-600 text-white hover:bg-green-700 shadow-lg";
        } else {
          return html`

          `;
        }

        return html`
          <button
            @click="${action}"
            ?disabled="${disabled}"
            class="w-full mb-8 flex justify-center items-center gap-2 px-4 py-3 rounded-xl font-medium transition-colors ${className}"
          >
            ${text}
          </button>
        `;
      };

      const ProgressBar = ({ appMode, progress }) => {
        const isVisible = appMode === "PROCESSING" ||
          appMode === "COMPLETED";

        return html`
          <div id="globalProgress" class="mb-8 ${isVisible
            ? ""
            : "hidden"}">
            <div class="flex justify-between mb-1">
              <span id="statusText" class="text-sm font-medium text-blue-700"
              >${progress.text}</span>
              <span id="percentageText" class="text-sm font-medium text-blue-700"
              >${progress.percent}%</span>
            </div>
            <div class="w-full bg-slate-200 rounded-full h-2.5">
              <div
                id="progressBar"
                class="bg-blue-600 h-2.5 rounded-full transition-all duration-300"
                style="width: ${progress.percent}%"
              >
              </div>
            </div>
          </div>
        `;
      };

      const PageResult = ({ page }) => {
        const statusColor = page.status === "Completed"
          ? "bg-green-500"
          : "bg-blue-500 animate-pulse";
        const statusTextClass = page.status === "Completed"
          ? "text-green-600"
          : "text-blue-600";

        // Function must be defined here for the component's scope
        const copyText = (e) => {
          const textarea = e.target.closest(".p-4.flex.flex-col")
            .querySelector("textarea");
          textarea.select();
          document.execCommand("copy");
          const originalText = e.target.textContent;
          e.target.textContent = "Copied!";
          setTimeout(() => e.target.textContent = originalText, 2000);
        };

        return html`
          <div
            class="bg-white rounded-xl shadow-lg border border-slate-200 overflow-hidden"
          >
            <div
              class="border-b border-slate-100 bg-slate-50 px-4 py-3 flex justify-between items-center"
            >
              <h3 class="font-semibold text-slate-700">Page ${page
                .pageNum}</h3>
              <div
                class="status-indicator flex items-center gap-2 text-xs font-medium text-slate-500"
              >
                <span class="status-dot w-2 h-2 rounded-full ${statusColor}"></span>
                <span class="status-text ${statusTextClass}">${page
                  .status}</span>
              </div>
            </div>
            <div
              class="grid grid-cols-1 md:grid-cols-2 divide-y md:divide-y-0 md:divide-x divide-slate-100"
            >
              <!-- Image Column -->
              <div
                class="p-4 bg-slate-50/50 flex items-start justify-center overflow-auto max-h-[600px] custom-scrollbar"
              >
                <!-- Show the captured image data -->
                ${page.imgData
                  ? html`
                    <img src="${page
                      .imgData}" class="shadow-lg max-w-full h-auto" />
                  `
                  : html`
                    <div class="text-slate-400 text-sm italic">Image pending...</div>
                  `}
              </div>
              <!-- Text Column -->
              <div class="p-4 flex flex-col h-[600px]">
                <div class="flex justify-between items-center mb-2">
                  <span
                    class="text-xs font-semibold text-slate-400 uppercase tracking-wider"
                  >Extracted Text</span>
                  <button
                    @click="${copyText}"
                    class="copy-btn text-xs text-blue-600 hover:text-blue-800 font-medium"
                  >
                    Copy Text
                  </button>
                </div>
                <textarea
                  class="extracted-text w-full flex-1 p-3 text-sm text-slate-700 border border-slate-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none resize-none custom-scrollbar font-mono leading-relaxed bg-white"
                  readonly
                  placeholder="Text will appear here after processing..."
                >${page.text}</textarea>
              </div>
            </div>
          </div>
        `;
      };

      const ResultsArea = (
        { processedPagesData, showResults, appMode },
      ) => {
        const isVisible = showResults &&
          (appMode === "PROCESSING" || appMode === "COMPLETED");

        return html`
          <div id="resultsContainer" class="space-y-12 ${isVisible
            ? ""
            : "hidden"}">
            ${processedPagesData.map((page) =>
              html`
                <div class="page-result">${PageResult({ page })}</div>
              `
            )}
          </div>
        `;
      };

      // Register the main application component
      customElements.define(
        "ocr-app",
        component(App, { useShadowDOM: false }),
      );
    </script>
  </body>
</html>
