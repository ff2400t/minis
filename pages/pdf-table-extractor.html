<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lit-Haunted PDF Table Extractor</title>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"
    ></script>
    <style>
      :root {
        --primary: #4f46e5;
        --primary-hover: #4338ca;
        --bg: #f8fafc;
        --card-bg: #ffffff;
        --text-main: #0f172a;
        --text-muted: #64748b;
        --border: #e2e8f0;
        --shadow:
          0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      }

      body {
        margin: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
        background-color: var(--bg);
        color: var(--text-main);
        line-height: 1.5;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 2rem;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        margin-bottom: 2rem;
        gap: 1rem;
      }

      h1 {
        font-size: 2rem;
        font-weight: 900;
        margin: 0;
        letter-spacing: -0.025em;
      }
      .subtitle {
        color: var(--text-muted);
        font-size: 0.875rem;
        margin-top: 0.25rem;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.625rem 1.25rem;
        border-radius: 0.75rem;
        font-weight: 700;
        font-size: 0.875rem;
        cursor: pointer;
        transition: all 0.2s;
        border: none;
        gap: 0.5rem;
      }

      .btn-primary {
        background: var(--primary);
        color: white;
        box-shadow: var(--shadow);
      }
      .btn-primary:hover {
        background: var(--primary-hover);
      }
      .btn-primary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .btn-ghost {
        background: transparent;
        color: var(--text-muted);
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .btn-ghost:hover {
        color: #ef4444;
      }

      .settings-card {
        background: var(--card-bg);
        padding: 1.5rem;
        border-radius: 1.25rem;
        border: 1px solid var(--border);
        box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
        margin-bottom: 1.5rem;
      }

      .settings-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 2rem;
        align-items: center;
      }

      .input-group {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }
      .label-tiny {
        font-size: 0.625rem;
        font-weight: 800;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.1em;
        white-space: nowrap;
      }

      input[type="text"] {
        padding: 0.4rem 0.75rem;
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        font-size: 0.875rem;
        background: #f1f5f9;
        outline: none;
      }

      input[type="range"] {
        flex: 1;
        accent-color: var(--primary);
        height: 6px;
      }

      /* DropZone */
      .dropzone-label {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 16rem;
        border: 2px dashed var(--border);
        border-radius: 1.5rem;
        cursor: pointer;
        background: white;
        transition: all 0.3s;
        margin-bottom: 1.5rem;
      }
      .dropzone-label:hover {
        background: #f8fafc;
        border-color: var(--primary);
      }
      .dropzone-label.active {
        border-color: var(--primary);
        ring: 2px solid #e0e7ff;
        transform: scale(1.01);
      }

      /* Table Components */
      .page-card {
        background: white;
        border-radius: 1.25rem;
        border: 1px solid var(--border);
        margin-bottom: 2rem;
        overflow: hidden;
      }
      .page-header {
        padding: 0.5rem 1.5rem;
        background: #f8fafc;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        font-size: 0.625rem;
        font-weight: 800;
        color: var(--text-muted);
        text-transform: uppercase;
      }

      .table-container {
        overflow-x: auto;
        width: 100%;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
      }
      tr {
        border-bottom: 1px solid #f1f5f9;
      }
      tr:hover {
        background: #f8fafc;
      }
      td {
        padding: 0.625rem 1.25rem;
        color: #334155;
        white-space: nowrap;
        border-right: 1px solid #f1f5f9;
      }
      .row-num {
        width: 2rem;
        color: #cbd5e1;
        font-family: monospace;
        text-align: center;
        border-right: 2px solid #f1f5f9;
      }

      /* Visual Modal */
      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.8);
        backdrop-filter: blur(4px);
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
      }
      .modal-content {
        background: white;
        border-radius: 1.5rem;
        width: 100%;
        max-width: 1000px;
        display: flex;
        flex-direction: column;
        max-height: 90vh;
        overflow: hidden;
      }
      .modal-header {
        padding: 1rem 2rem;
        background: #0f172a;
        color: white;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .modal-body {
        flex: 1;
        overflow: auto;
        background: #f1f5f9;
        padding: 2rem;
        position: relative;
      }
      .modal-footer {
        padding: 1rem 2rem;
        border-top: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .visual-canvas-wrapper {
        position: relative;
        margin: 0 auto;
        background: white;
        box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
      }
      .visual-overlay {
        position: absolute;
        inset: 0;
        cursor: crosshair;
      }

      /* Anchor UI */
      .anchor-track {
        position: relative;
        height: 48px;
        background: #f1f5f9;
        border-radius: 0.5rem;
        margin: 1rem 0;
        border: 1px solid var(--border);
        cursor: crosshair;
      }
      .anchor-marker {
        position: absolute;
        top: -4px;
        width: 2px;
        height: 56px;
        background: var(--primary);
        z-index: 10;
      }
      .anchor-marker::after {
        content: "✕";
        position: absolute;
        top: -10px;
        left: -8px;
        width: 16px;
        height: 16px;
        background: var(--primary);
        color: white;
        font-size: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        border: 2px solid white;
      }

      .toggle-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #eef2ff;
        padding: 1rem;
        border-radius: 1rem;
        margin-bottom: 1rem;
        border: 1px solid #e0e7ff;
      }

      .error-msg {
        background: #fef2f2;
        color: #dc2626;
        padding: 1rem;
        border-radius: 0.75rem;
        text-align: center;
        font-size: 0.875rem;
        margin-bottom: 1rem;
      }

      .loading-spinner {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 4rem;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid var(--primary);
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <script type="module">
      import {
        html,
        ifDefined,
        map,
        render,
        when,
      } from "/vendor/lit-html@3.3.2.js";
      import {
        component,
        useEffect,
        useReducer,
        useRef,
        useState,
      } from "/vendor/haunted@6.1.0.js";

      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

      const initialState = {
        isProcessing: false,
        extractedData: [],
        error: null,
        lastFile: null,
        triggerWord: "Date",
        rowLeniency: 8,
        colLeniency: 45,
        copyStatus: {},
        showManualSettings: false,
        showVisualModal: false,
        manualAnchors: null,
        showAllPages: false,
      };

      function reducer(state, action) {
        switch (action.type) {
          case "SET_CONFIG":
            return { ...state, [action.key]: action.value };
          case "START_PROCESSING":
            return {
              ...state,
              isProcessing: true,
              error: null,
              extractedData: [],
              lastFile: action.file || state.lastFile,
            };
          case "FINISH_PROCESSING":
            return {
              ...state,
              isProcessing: false,
              extractedData: action.data,
              error: null,
              manualAnchors: action.anchors || state.manualAnchors,
            };
          case "SET_ERROR":
            return {
              ...state,
              isProcessing: false,
              error: action.error,
            };
          case "RESET":
            return {
              ...state,
              lastFile: null,
              extractedData: [],
              error: null,
              manualAnchors: null,
            };
          case "TOGGLE_VISUAL_MODAL":
            return { ...state, showVisualModal: action.value };
          case "SET_ANCHORS":
            return { ...state, manualAnchors: action.anchors };
          case "SET_COPY_STATUS":
            return { ...state, copyStatus: action.status };
          default:
            return state;
        }
      }

      function DropZone() {
        const { disabled } = this;
        const handleFileChange = (e) => {
          if (disabled) return;
          this.dispatchEvent(
            new CustomEvent("file-selected", {
              detail: e.target.files,
            }),
          );
          e.target.value = null;
        };
        const handleDragOver = (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (!disabled) e.currentTarget.classList.add("active");
        };
        const handleDragLeave = (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.currentTarget.classList.remove("active");
        };
        const handleDrop = (e) => {
          e.preventDefault();
          e.stopPropagation();
          handleDragLeave(e);
          if (!disabled && e.dataTransfer.files?.length > 0) {
            this.dispatchEvent(
              new CustomEvent("file-selected", {
                detail: e.dataTransfer.files,
              }),
            );
          }
        };

        return html`
          <label
            class="dropzone-label ${disabled ? "disabled" : ""}"
            @dragover="${handleDragOver}"
            @dragleave="${handleDragLeave}"
            @drop="${handleDrop}"
          >
            <div style="pointer-events: none; text-align: center;">
              <svg
                width="32"
                height="32"
                viewBox="0 0 24 24"
                fill="none"
                stroke="#94a3b8"
                stroke-width="2"
                style="margin-bottom: 1rem;"
              >
                <path
                  d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"
                />
              </svg>
              <p style="font-size: 0.875rem; color: #64748b;">
                <span style="font-weight: 700; color: #1e293b;"
                >Click to upload PDF</span> or drag and drop
              </p>
            </div>
            <input
              type="file"
              accept="application/pdf"
              style="display: none;"
              @change="${handleFileChange}"
              ?disabled="${disabled}"
            />
          </label>
        `;
      }
      customElements.define(
        "drop-zone",
        component(DropZone, {
          properties: { disabled: Boolean },
          useShadowDOM: false,
        }),
      );

      function VisualAlignmentModal(
        { file, anchors, onUpdate, onClose },
      ) {
        const canvasRef = useRef(null);
        const overlayRef = useRef(null);
        const [pdfDim, setPdfDim] = useState({ w: 0, h: 0 });

        useEffect(() => {
          if (!file) return;
          let active = true;
          const renderPdf = async () => {
            try {
              const arrayBuffer = await file.arrayBuffer();
              const pdf = await pdfjsLib.getDocument({
                data: arrayBuffer,
              }).promise;
              const page = await pdf.getPage(1);
              const viewport = page.getViewport({ scale: 1.2 });
              if (!active || !canvasRef.current) return;
              const canvas = canvasRef.current;
              const context = canvas.getContext("2d");
              canvas.height = viewport.height;
              canvas.width = viewport.width;
              setPdfDim({ w: viewport.width, h: viewport.height });
              await page.render({
                canvasContext: context,
                viewport: viewport,
              }).promise;
            } catch (e) {
              console.error(e);
            }
          };
          renderPdf();
          return () => {
            active = false;
          };
        }, [file]);

        const handleOverlayClick = (e) => {
          const rect = overlayRef.current.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 600;
          onUpdate([...anchors, x].sort((a, b) => a - b));
        };

        return html`
          <div class="modal-backdrop" @click="${onClose}">
            <div class="modal-content" @click="${(e) =>
              e.stopPropagation()}">
              <div class="modal-header">
                <div>
                  <h2 style="margin:0; font-size: 1.125rem;">
                    Visual Column Aligner
                  </h2>
                  <p style="margin:0; font-size: 0.75rem; color: #94a3b8;">
                    Place markers to split columns. Showing page 1.
                  </p>
                </div>
                <button
                  @click="${onClose}"
                  class="btn btn-ghost"
                  style="color: white;"
                >
                  ✕ Close
                </button>
              </div>
              <div class="modal-body">
                <div class="visual-canvas-wrapper" style="width: ${pdfDim
                  .w}px;">
                  <canvas ref="${canvasRef}"></canvas>
                  <div
                    class="visual-overlay"
                    ref="${overlayRef}"
                    @click="${handleOverlayClick}"
                  >
                    ${map(anchors, (x, i) =>
                      html`
                        <div
                          class="anchor-marker"
                          style="left: ${(x / 600) *
                            100}%; height: 100%; top: 0;"
                          @click="${(e) => {
                            e.stopPropagation();
                            onUpdate(
                              anchors.filter((_, idx) => idx !== i),
                            );
                          }}"
                        >
                        </div>
                      `)}
                  </div>
                </div>
              </div>
              <div class="modal-footer">
                <span class="label-tiny">${anchors
                  .length} Split Points</span>
                <div style="display: flex; gap: 1rem;">
                  <button @click="${() =>
                    onUpdate([])}" class="btn btn-ghost">
                    Clear
                  </button>
                  <button @click="${onClose}" class="btn btn-primary">
                    Save Aligner
                  </button>
                </div>
              </div>
            </div>
          </div>
        `;
      }
      customElements.define(
        "visual-modal",
        component(VisualAlignmentModal, { useShadowDOM: false }),
      );

      function ColumnAdjuster({ anchors, onUpdate, onOpenVisual }) {
        const trackRef = useRef(null);
        const handleTrackClick = (e) => {
          const rect = trackRef.current.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 600;
          onUpdate([...anchors, x].sort((a, b) => a - b));
        };

        return html`
          <div
            class="settings-card"
            style="margin-top: 1rem; border-color: #c7d2fe;"
          >
            <div
              style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;"
            >
              <div style="display: flex; gap: 1rem; align-items: center;">
                <span class="label-tiny">Manual Column Map</span>
                <button
                  @click="${onOpenVisual}"
                  class="btn btn-primary"
                  style="padding: 0.4rem 0.8rem; font-size: 0.7rem;"
                >
                  Open Visual Editor
                </button>
              </div>
            </div>
            <div class="anchor-track" ref="${trackRef}" @click="${handleTrackClick}">
              ${map(anchors, (x, i) =>
                html`
                  <div
                    class="anchor-marker"
                    style="left: ${(x / 600) * 100}%"
                    @click="${(e) => {
                      e.stopPropagation();
                      onUpdate(anchors.filter((_, idx) => idx !== i));
                    }}"
                  >
                  </div>
                `)}
            </div>
            <div style="text-align: right;">
              <button
                @click="${() => onUpdate(null)}"
                class="btn btn-ghost"
                style="font-size: 0.6rem;"
              >
                Reset to Auto
              </button>
            </div>
          </div>
        `;
      }
      customElements.define(
        "column-adjuster",
        component(ColumnAdjuster, { useShadowDOM: false }),
      );

      function TablePage({ table }) {
        return html`
          <div class="page-card">
            <div class="page-header">
              <span>Page ${table.page}</span>
              <span>${table.rows.length} Rows Detected</span>
            </div>
            <div class="table-container">
              <table>
                <tbody>
                  ${map(table.rows, (row, rIdx) =>
                    html`
                      <tr>
                        <td class="row-num">${rIdx + 1}</td>
                        ${map(row, (cell) =>
                          html`
                            <td>${cell || "·"}</td>
                          `)}
                      </tr>
                    `)}
                </tbody>
              </table>
            </div>
          </div>
        `;
      }
      customElements.define(
        "table-page",
        component(TablePage, { useShadowDOM: false }),
      );

      function App() {
        const [state, dispatch] = useReducer(reducer, initialState);

        const extractTableFromPdf = async (file, state) => {
          console.log(state);
          if (!file) return;
          dispatch({ type: "START_PROCESSING", file });
          try {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({
              data: arrayBuffer,
            }).promise;
            let hasFoundInitialStart = false;
            let globalAnchors = state.manualAnchors;
            console.log(globalAnchors);
            let results = [];
            const searchTrigger = state.triggerWord.toLowerCase()
              .trim();

            for (let i = 1; i <= pdf.numPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();
              const items = textContent.items.map((item) => ({
                str: item.str,
                x: item.transform[4],
                y: item.transform[5],
                centerX: item.transform[4] + (item.width / 2),
              })).filter((item) => item.str.trim().length > 0);

              if (items.length === 0) continue;
              const triggerItem = items.find((item) =>
                item.str.toLowerCase().includes(searchTrigger)
              );
              if (!hasFoundInitialStart && !triggerItem) continue;
              if (!hasFoundInitialStart && triggerItem) {
                hasFoundInitialStart = true;
              }

              const pageRows = [];
              items.sort((a, b) => b.y - a.y).forEach((item) => {
                let foundRow = pageRows.find((row) =>
                  Math.abs(row.y - item.y) < Number(state.rowLeniency)
                );
                if (foundRow) foundRow.items.push(item);
                else pageRows.push({ y: item.y, items: [item] });
              });

              // recompute the anchors if the globalAnchors are not being
              // if they are being show then use the globalAnchor value
              if (!state.showManualSettings) {
                const columnGroups = [];
                [...items].sort((a, b) => a.centerX - b.centerX)
                  .forEach((item) => {
                    let group = columnGroups.find((g) =>
                      Math.abs(g.avgCenter - item.centerX) <
                        Number(state.colLeniency)
                    );
                    if (group) {
                      group.items.push(item);
                      group.avgCenter = group.items.reduce((acc, it) =>
                        acc + it.centerX, 0) / group.items.length;
                    } else {
                      columnGroups.push({
                        avgCenter: item.centerX,
                        items: [item],
                      });
                    }
                  });
                globalAnchors = columnGroups.map((g) => g.avgCenter)
                  .sort((a, b) => a - b);
              }

              const processedRows = pageRows.map((row) => {
                const rowData = new Array(globalAnchors.length).fill(
                  "",
                );
                row.items.forEach((item) => {
                  let bestIdx = -1, minDiff = Infinity;
                  globalAnchors.forEach((anchor, idx) => {
                    const diff = Math.abs(anchor - item.centerX);
                    if (diff < minDiff) {
                      minDiff = diff;
                      bestIdx = idx;
                    }
                  });
                  if (bestIdx !== -1) {
                    rowData[bestIdx] = rowData[bestIdx]
                      ? (rowData[bestIdx] + " " + item.str)
                      : item.str;
                  }
                });
                return rowData;
              });
              results.push({ page: i, rows: processedRows });
            }
            dispatch({
              type: "FINISH_PROCESSING",
              data: results,
              anchors: globalAnchors,
            });
          } catch (err) {
            dispatch({ type: "SET_ERROR", error: err.message });
          }
        };

        const copyAll = () => {
          const text = state.extractedData.flatMap((t) => t.rows).map(
            (row) => row.join("\t"),
          ).join("\n");
          const el = document.createElement("textarea");
          el.value = text;
          document.body.appendChild(el);
          el.select();
          document.execCommand("copy");
          document.body.removeChild(el);
          dispatch({ type: "SET_COPY_STATUS", status: { all: true } });
          setTimeout(
            () => dispatch({ type: "SET_COPY_STATUS", status: {} }),
            2000,
          );
        };

        const displayedData = state.showAllPages
          ? state.extractedData
          : state.extractedData.slice(0, 1);

        return html`
          <div class="container">
            <header>
              <div>
                <h1>PDF Table Extractor</h1>
                <p class="subtitle">
                  Cleanly extract tabular data using anchor keywords.
                </p>
              </div>
              ${when(state.extractedData.length > 0, () =>
                html`
                  <div style="display: flex; gap: 1rem;">
                    <button class="btn btn-ghost" @click="${() =>
                      dispatch({ type: "RESET" })}">Reset</button>
                    <button class="btn btn-primary" @click="${copyAll}">
                      ${state.copyStatus.all
                        ? "✓ Copied"
                        : "Copy All Results"}
                    </button>
                  </div>
                `)}
            </header>

            <div class="settings-card">
              <div class="settings-grid">
                <div class="input-group">
                  <span class="label-tiny">Keyword</span>
                  <input type="text" .value="${state
                    .triggerWord}" @input="${(e) =>
                    dispatch({
                      type: "SET_CONFIG",
                      key: "triggerWord",
                      value: e.target.value,
                    })}" />
                </div>
                <div class="input-group" style="flex: 1;">
                  <span class="label-tiny">Row (px)</span>
                  <input
                    type="range"
                    min="1"
                    max="30"
                    .value="${state.rowLeniency}"
                    @input="${(e) =>
                      dispatch({
                        type: "SET_CONFIG",
                        key: "rowLeniency",
                        value: e.target.value,
                      })}"
                  />
                </div>
                <div class="input-group" style="flex: 1;">
                  <span class="label-tiny">Col (px)</span>
                  <input
                    type="range"
                    min="10"
                    max="150"
                    .value="${state.colLeniency}"
                    @input="${(e) =>
                      dispatch({
                        type: "SET_CONFIG",
                        key: "colLeniency",
                        value: e.target.value,
                      })}"
                  />
                </div>
                <div
                  style="display: flex; gap: 1rem; align-items: center; border-left: 1px solid var(--border); padding-left: 2rem;"
                >
                  <label
                    style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;"
                  >
                    <input
                      type="checkbox"
                      .checked="${state.showManualSettings}"
                      @change="${(e) =>
                        dispatch({
                          type: "SET_CONFIG",
                          key: "showManualSettings",
                          value: e.target.checked,
                        })}"
                    />
                    <span style="font-size: 0.75rem; font-weight: 600;"
                    >Manual Map</span>
                  </label>
                  <button
                    class="btn btn-primary"
                    style="padding: 0.5rem 1rem;"
                    @click="${() =>
                      extractTableFromPdf(state.lastFile, state)}"
                    ?disabled="${!state.lastFile}"
                  >
                    Reparse
                  </button>
                </div>
              </div>
              ${when(state.showManualSettings, () =>
                html`
                  <column-adjuster
                    .anchors="${state.manualAnchors || []}"
                    .onUpdate="${(anchors) =>
                      dispatch({ type: "SET_ANCHORS", anchors })}"
                    .onOpenVisual="${() =>
                      dispatch({
                        type: "TOGGLE_VISUAL_MODAL",
                        value: true,
                      })}"
                  >
                  </column-adjuster>
                `)}
            </div>

            ${when(!state.lastFile, () =>
              html`
                <drop-zone
                  ?disabled="${state.isProcessing}"
                  @file-selected="${(e) =>
                    extractTableFromPdf(e.detail[0], state)}"
                ></drop-zone>
              `)} ${when(state.error, () =>
                html`
                  <div class="error-msg">${state.error}</div>
                `)} ${when(state.isProcessing, () =>
                html`
                  <div class="loading-spinner">
                    <div class="spinner"></div>
                    <p style="margin-top: 1rem; font-weight: 700;">
                      Scanning PDF Pages...
                    </p>
                  </div>
                `)} ${when(state.extractedData.length > 0, () =>
                html`
                  <div class="toggle-container">
                    <div>
                      <h3 style="margin:0; font-size: 0.875rem;">Extraction Results</h3>
                      <p style="margin:0; font-size: 0.75rem; color: #4338ca;">
                        Found table on ${state.extractedData
                          .length} pages
                      </p>
                    </div>
                    <label
                      style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;"
                    >
                      <span class="label-tiny" style="color: #4338ca;"
                      >Show All Pages</span>
                      <input
                        type="checkbox"
                        .checked="${state.showAllPages}"
                        @change="${(e) =>
                          dispatch({
                            type: "SET_CONFIG",
                            key: "showAllPages",
                            value: e.target.checked,
                          })}"
                      />
                    </label>
                  </div>
                  <div class="results-list">
                    ${map(displayedData, (table) =>
                      html`
                        <table-page .table="${table}"></table-page>
                      `)} ${when(
                        !state.showAllPages &&
                          state.extractedData.length > 1,
                        () =>
                          html`
                            <div
                              style="text-align: center; padding: 2rem; border: 2px dashed var(--border); border-radius: 1rem;"
                            >
                              <p
                                style="color: var(--text-muted); font-size: 0.75rem; font-weight: 700;"
                              >
                                + ${state.extractedData.length -
                                  1} MORE PAGES HIDDEN
                              </p>
                              <button class="btn btn-ghost" @click="${() =>
                                dispatch({
                                  type: "SET_CONFIG",
                                  key: "showAllPages",
                                  value: true,
                                })}">
                                Expand All Results
                              </button>
                            </div>
                          `,
                      )}
                  </div>
                `)} ${when(state.showVisualModal, () =>
                html`
                  <visual-modal
                    .file="${ifDefined(state.lastFile)}"
                    .anchors="${state.manualAnchors || []}"
                    .onUpdate="${(a) =>
                      dispatch({ type: "SET_ANCHORS", anchors: a })}"
                    .onClose="${() =>
                      dispatch({
                        type: "TOGGLE_VISUAL_MODAL",
                        value: false,
                      })}"
                  >
                  </visual-modal>
                `)}
          </div>
        `;
      }

      customElements.define(
        "main-app",
        component(App, { useShadowDOM: false }),
      );
      render(
        html`
          <main-app></main-app>
        `,
        document.getElementById("app"),
      );
    </script>
  </body>
</html>
