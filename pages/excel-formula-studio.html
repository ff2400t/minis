<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Formula Studio</title>
    <style>
      /* FIX: Ensure height inheritance works across html and body */
      html {
        height: 100%;
      }

      :root {
        /* Dark Theme (Default) */
        --bg-color: #1e1e1e;
        --panel-bg: #2d2d2d;
        --header-bg: #151515;
        --text-color: #d4d4d4;
        --border-color: #333;
        --accent-color: #107c10;
        --accent-hover: #0e600e;

        /* Token Colors */
        --c-function: #569cd6;
        --c-string: #ce9178;
        --c-number: #b5cea8;
        --c-bool: #569cd6;
        --c-ref: #9cdcfe;
        --c-operator: #d4d4d4;

        /* Rainbow Brackets */
        --depth-0: #ffd700;
        --depth-1: #da70d6;
        --depth-2: #179fff;
        --depth-3: #9fff17;
      }

      .light-theme {
        /* Light Theme overrides */
        --bg-color: #f3f3f3;
        --panel-bg: #ffffff;
        --header-bg: #e0e0e0;
        --text-color: #333333;
        --border-color: #cccccc;
        --accent-color: #217346;

        --c-function: #0000ff;
        --c-string: #a31515;
        --c-number: #098658;
        --c-bool: #0000ff;
        --c-ref: #795e26;
        --c-operator: #333333;

        --depth-0: #e0ac00;
        --depth-1: #af00db;
        --depth-2: #0066cc;
        --depth-3: #4b9e00;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        /* Using 100vh here works with html { height: 100%; } */
        height: 100vh;
        overflow: hidden;
        background-color: var(--bg-color);
        color: var(--text-color);
        transition: background-color 0.3s, color 0.3s;
      }

      /* Styles previously inside the component, now targeting the element directly */
      excel-studio-app {
        display: flex;
        flex-direction: column;
        height: 100%;
        background-color: var(--bg-color);
        color: var(--text-color);
      }

      header {
        background-color: var(--header-bg);
        padding: 0.8rem 1.5rem;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
      }

      h1 {
        margin: 0;
        font-size: 1.2rem;
        color: var(--accent-color);
        font-weight: 600;
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .status-indicator {
        font-size: 0.8rem;
        padding: 4px 10px;
        border-radius: 12px;
        background-color: #333;
        color: #aaa;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .status-valid {
        color: #4caf50;
        background: rgba(76, 175, 80, 0.1);
        border: 1px solid #4caf50;
      }
      .status-error {
        color: #f44336;
        background: rgba(244, 67, 54, 0.1);
        border: 1px solid #f44336;
      }

      .toolbar {
        display: flex;
        gap: 8px;
      }

      button {
        background-color: var(--panel-bg);
        color: var(--text-color);
        border: 1px solid var(--border-color);
        padding: 6px 14px;
        cursor: pointer;
        border-radius: 4px;
        font-size: 0.85rem;
        transition: all 0.2s;
        font-weight: 500;
      }

      button:hover {
        background-color: rgba(128, 128, 128, 0.2);
      }
      button.primary {
        background-color: var(--accent-color);
        border-color: var(--accent-color);
        color: white;
      }
      button.primary:hover {
        background-color: var(--accent-hover);
      }

      .container {
        display: flex;
        flex: 1;
        flex-direction: column;
        padding: 15px;
        gap: 15px;
        overflow: hidden;
        position: relative;
      }

      @media (min-width: 768px) {
        .container {
          flex-direction: row;
        }
      }

      .panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        background-color: var(--panel-bg);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        overflow: hidden;
        min-height: 200px;
        transition: background-color 0.3s;
      }

      .panel-header {
        padding: 8px 12px;
        background-color: rgba(128, 128, 128, 0.1);
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #888;
        border-bottom: 1px solid var(--border-color);
        flex-shrink: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      textarea {
        flex: 1;
        background-color: transparent;
        color: var(--text-color);
        border: none;
        padding: 15px;
        resize: none;
        font-family: "Consolas", "Monaco", "Courier New", monospace;
        font-size: 14px;
        line-height: 1.5;
        outline: none;
        width: 100%;
        box-sizing: border-box;
      }

      #output {
        flex: 1;
        padding: 15px;
        font-family: "Consolas", "Monaco", "Courier New", monospace;
        font-size: 14px;
        line-height: 1.5;
        overflow: auto;
        white-space: pre-wrap;
        word-break: break-all;
      }

      /* Token Classes */
      .token-function {
        color: var(--c-function);
        font-weight: bold;
        cursor: help;
        border-bottom: 1px dotted transparent;
      }
      .token-function:hover {
        border-bottom-color: var(--c-function);
      }
      .token-string {
        color: var(--c-string);
      }
      .token-number {
        color: var(--c-number);
      }
      .token-bool {
        color: var(--c-bool);
      }
      .token-ref {
        color: var(--c-ref);
      }
      .token-operator {
        color: var(--c-operator);
      }
      .token-bracket {
        color: white;
      } /* Base bracket color for depth cycling */

      .depth-0 {
        color: var(--depth-0);
      }
      .depth-1 {
        color: var(--depth-1);
      }
      .depth-2 {
        color: var(--depth-2);
      }
      .depth-3 {
        color: var(--depth-3);
      }

      /* History Modal */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 2000;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .modal-content {
        background: var(--panel-bg);
        border: 1px solid var(--border-color);
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      }
      .modal-header {
        padding: 15px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .modal-body {
        padding: 0;
        overflow-y: auto;
        flex: 1;
      }
      .history-item {
        padding: 12px 15px;
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        transition: background 0.1s;
      }
      .history-item:hover {
        background-color: rgba(128, 128, 128, 0.1);
      }
      .history-time {
        font-size: 0.75rem;
        color: #888;
        margin-bottom: 4px;
      }
      .history-snippet {
        font-family: monospace;
        font-size: 0.85rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: var(--text-color);
      }

      /* Scrollbar Styling for all components */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 5px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #666;
      }
    </style>
  </head>
  <body>
    <!-- Main component container -->
    <excel-studio-app></excel-studio-app>

    <!-- Tooltip Element (Needs to stay outside the shadow DOM for global positioning) -->
    <div
      id="tooltip"
      style="display: none; position: fixed; background-color: #252526; color: #eee; padding: 10px; border-radius: 4px; border: 1px solid #454545; font-size: 0.85rem; z-index: 1000; max-width: 300px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); pointer-events: none"
    >
      <span
        class="tooltip-title"
        style="color: var(--accent-color); font-weight: bold; margin-bottom: 4px; display: block"
      ></span>
      <span
        class="tooltip-syntax"
        style="font-family: monospace; background: rgba(0, 0, 0, 0.2); padding: 2px 4px; display: block; margin-bottom: 4px; color: #aaa"
      ></span>
      <span class="tooltip-desc"></span>
    </div>

    <!-- Scripts -->
    <script type="module">
      import { html, render } from "/vendor/lit-html@3.3.2.js";
      import {
        component,
        useCallback,
        useEffect,
        useMemo,
        useState,
      } from "/vendor/haunted@6.1.0.js";

      // --- 1. Constants and Shared Data ---

      // Updated example formula using modern functions
      const INITIAL_FORMULA =
        `=IFERROR(XLOOKUP(A2, Employees!B:B, Employees!C:D, "Not Found"), "Invalid Employee ID")`;

      const rules = [
        { type: "string", regex: /"(""|[^"])*"/ },
        {
          type: "ref",
          regex:
            /('?[a-zA-Z0-9\s\[\]]+'?!)?\$?[a-zA-Z]+\$?\d+(:\$?[a-zA-Z]+\$?\d+)?/,
        },
        { type: "function", regex: /[a-zA-Z\._]+(?=\()/ },
        { type: "bool", regex: /TRUE|FALSE/i },
        { type: "number", regex: /\b\d+(\.\d+)?\b/ },
        { type: "bracket", regex: /[\(\)]/ },
        { type: "comma", regex: /,/ },
        { type: "operator", regex: /[=&+\-*/^<>%]+/ },
        { type: "whitespace", regex: /\s+/ },
        { type: "unknown", regex: /./ },
      ];

      const functionHelp = {
        "IF": {
          syntax: "IF(logical_test, value_if_true, [value_if_false])",
          desc:
            "Checks a condition and returns one value if TRUE, another if FALSE.",
        },
        "IFERROR": {
          syntax: "IFERROR(value, value_if_error)",
          desc:
            "Returns a value you specify if a formula evaluates to an error; otherwise, returns the result of the formula.",
        },
        "VLOOKUP": {
          syntax:
            "VLOOKUP(lookup_value, table_array, col_index, [range_lookup])",
          desc:
            "Looks for a value in the leftmost column of a table and returns a value in the same row.",
        },
        "XLOOKUP": {
          syntax:
            "XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found], [match_mode], [search_mode])",
          desc:
            "Searches a range or array, and returns the item corresponding to the first match it finds.",
        },
        "INDEX": {
          syntax: "INDEX(array, row_num, [col_num], [area_num])",
          desc:
            "Returns a value from a table or range at a given position.",
        },
        "MATCH": {
          syntax: "MATCH(lookup_value, lookup_array, [match_type])",
          desc: "Returns the relative position of an item in an array.",
        },
        "SUM": {
          syntax: "SUM(number1, [number2], ...)",
          desc: "Adds all the numbers in a range of cells.",
        },
        "AVERAGE": {
          syntax: "AVERAGE(number1, [number2], ...)",
          desc:
            "Returns the average (arithmetic mean) of the arguments.",
        },
        "SUMIF": {
          syntax: "SUMIF(range, criteria, [sum_range])",
          desc: "Adds the cells specified by a given criteria.",
        },
        "COUNT": {
          syntax: "COUNT(value1, [value2], ...)",
          desc: "Counts the number of cells that contain numbers.",
        },
        "COUNTIF": {
          syntax: "COUNTIF(range, criteria)",
          desc:
            "Counts the number of cells within a range that meet the given criteria.",
        },
        "COUNTA": {
          syntax: "COUNTA(value1, [value2], ...)",
          desc:
            "Counts the number of cells that are not empty in a range.",
        },
        "CONCATENATE": {
          syntax: "CONCATENATE(text1, [text2], ...)",
          desc: "Joins several text items into one text item.",
        },
        "TEXT": {
          syntax: "TEXT(value, format_text)",
          desc: "Formats a number and converts it to text.",
        },
        "ISBLANK": {
          syntax: "ISBLANK(value)",
          desc: "Returns TRUE if the value is blank.",
        },
        "RIGHT": {
          syntax: "RIGHT(text, [num_chars])",
          desc: "Returns the last character(s) in a text string.",
        },
        "LEFT": {
          syntax: "LEFT(text, [num_chars])",
          desc: "Returns the first character(s) in a text string.",
        },
        "MID": {
          syntax: "MID(text, start_num, num_chars)",
          desc:
            "Returns a specific number of characters from a text string starting at the position you specify.",
        },
        "AND": {
          syntax: "AND(logical1, [logical2], ...)",
          desc:
            "Checks whether all arguments are TRUE, and returns TRUE if all arguments are TRUE.",
        },
        "OR": {
          syntax: "OR(logical1, [logical2], ...)",
          desc:
            "Checks whether any of the arguments are TRUE, and returns TRUE or FALSE.",
        },
        "TODAY": {
          syntax: "TODAY()",
          desc: "Returns the current date.",
        },
        "NOW": {
          syntax: "NOW()",
          desc: "Returns the current date and time.",
        },
        "MAX": {
          syntax: "MAX(number1, [number2], ...)",
          desc: "Returns the largest value in a set of values.",
        },
        "MIN": {
          syntax: "MIN(number1, [number2], ...)",
          desc: "Returns the smallest value in a set of values.",
        },
        "FILTER": {
          syntax: "FILTER(array, include, [if_empty])",
          desc: "Filters a range or array based on a boolean array.",
        },
        "SORT": {
          syntax: "SORT(array, [sort_index], [sort_order], [by_col])",
          desc: "Sorts the contents of a range or array.",
        },
        "UNIQUE": {
          syntax: "UNIQUE(array, [by_col], [exactly_once])",
          desc: "Returns a list of unique values in a range or array.",
        },
        "LAMBDA": {
          syntax: "LAMBDA([parameter1, ...], calculation)",
          desc:
            "Creates a custom, reusable function that can be called by name.",
        },
        "SEQUENCE": {
          syntax: "SEQUENCE(rows, [columns], [start], [step])",
          desc: "Generates a list of sequential numbers in an array.",
        },
      };

      // --- 2. Shared Utilities ---

      function tokenize(str) {
        let tokens = [];
        let remaining = str;
        while (remaining.length > 0) {
          let match = null, tokenType = null;
          for (let rule of rules) {
            let m = remaining.match(
              new RegExp("^" + rule.regex.source, "i"),
            );
            if (m) {
              match = m[0];
              tokenType = rule.type;
              break;
            }
          }
          if (match) {
            tokens.push({ type: tokenType, value: match });
            remaining = remaining.substring(match.length);
          } else {
            tokens.push({ type: "unknown", value: remaining[0] });
            remaining = remaining.substring(1);
          }
        }
        return tokens;
      }

      function escapeHtml(text) {
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;")
          .replace(/>/g, "&gt;").replace(/"/g, "&quot;");
      }

      // PURE FUNCTION for Text Formatting
      function formatFormulaText(formula) {
        const tokens = tokenize(formula);
        let formattedText = "";
        let depth = 0;
        const indentSize = 4;

        tokens.forEach((token) => {
          // Ignore existing whitespace when formatting
          if (token.type === "whitespace") return;

          if (token.value === "(") {
            depth++;
            formattedText += token.value;
            formattedText += "\n" + " ".repeat(depth * indentSize);
          } else if (token.value === ")") {
            depth = Math.max(0, depth - 1);
            formattedText += "\n" + " ".repeat(depth * indentSize);
            formattedText += token.value;
          } else if (token.value === ",") {
            formattedText += ",";
            formattedText += "\n" + " ".repeat(depth * indentSize);
          } else {
            formattedText += token.value;
          }
        });

        return formattedText.trim();
      }

      // --- 3. Haunted Component ---

      function ExcelStudioApp() {
        const [formula, setFormula] = useState(INITIAL_FORMULA);
        const [renderedHtml, setRenderedHtml] = useState([]); // Store array of lit-html fragments
        const [status, setStatus] = useState({
          msg: "Ready",
          type: "",
        });
        const [isLight, setIsLight] = useState(false);
        const [isHistoryOpen, setIsHistoryOpen] = useState(false);
        const [historyList, setHistoryList] = useState([]);
        const [textareaValue, setTextareaValue] = useState(formula); // Separate state for textarea

        // --- Theme Effect ---
        useEffect(() => {
          const preferredTheme = localStorage.getItem("excel-theme");
          if (preferredTheme === "light") {
            document.body.classList.add("light-theme");
            setIsLight(true);
          }
        }, []);

        // --- Formula Rendering and Validation Logic (Callback) ---
        const renderFormula = useCallback((formulaToRender) => {
          if (!formulaToRender) {
            setRenderedHtml([html`
              <span style="color:#777; font-style:italic;"
              >Start typing to see magic...</span>
            `]);
            setStatus({ msg: "Ready", type: "" });
            return;
          }

          const tokens = tokenize(formulaToRender);
          let htmlOutput = [];
          let depth = 0;
          let balanceError = false;
          console.log(tokens);

          tokens.forEach((token) => {
            // Highlighting & Depth Calculation
            if (token.type === "bracket") {
              if (token.value === "(") {
                // deno-fmt-ignore
                htmlOutput.push(html`<span class="token-bracket depth-${depth % 4}">${token .value}</span>`);
                depth++;
              } else {
                depth--;
                if (depth < 0) balanceError = true; // Closed more than opened
                // deno-fmt-ignore
                htmlOutput.push(html`<span class="token-bracket depth-${Math.max( 0, depth, ) % 4}">${token.value}</span>`);
              }
            } else if (token.type === "whitespace") {
              htmlOutput.push(token.value);
            } else {
              const content = escapeHtml(token.value);
              if (token.type === "function") {
                // Functions need the mouse handlers for tooltips

                // deno-fmt-ignore
                const a = html`<span class="token-${token.type}" @mousemove="${(e) => handleTooltip(e, token.value)}" @mouseleave="${handleTooltipHide}" >${content}</span>`;
                htmlOutput.push(a);
              } else {
                // deno-fmt-ignore
                htmlOutput.push(html`<span class="token-${token.type}">${content}</span>`);
              }
            }
          });
          console.log(htmlOutput);

          setRenderedHtml(htmlOutput);

          // Validation Check
          if (balanceError || depth !== 0) {
            setStatus({
              msg: `Unbalanced Parentheses (Depth: ${depth})`,
              type: "error",
            });
          } else {
            setStatus({ msg: "Formula Valid", type: "valid" });
          }
        }, [setRenderedHtml, setStatus]);

        // --- Run render when formula changes ---
        useEffect(() => {
          renderFormula(formula);
        }, [formula, renderFormula]);

        // --- Handlers ---

        const handleInput = (e) => {
          const newFormula = e.target.value;
          setTextareaValue(newFormula); // Update textarea value
          setFormula(newFormula); // Update the formula for live rendering
        };

        const toggleTheme = () => {
          const newState = !isLight;
          setIsLight(newState);
          document.body.classList.toggle("light-theme", newState);
          localStorage.setItem(
            "excel-theme",
            newState ? "light" : "dark",
          );
        };

        const minify = () => {
          const tokens = tokenize(formula);
          let minified = "";
          tokens.forEach((t) => {
            if (t.type !== "whitespace") minified += t.value;
          });
          // Remove extra spaces around operators and commas
          minified = minified.replace(
            /\s*([\,\(\)=<>+\-*/])\s*/g,
            "$1",
          );
          setFormula(minified);
          setTextareaValue(minified);
        };

        const beautify = () => {
          // Use the pure text formatting function to get the clean string
          const formattedText = formatFormulaText(formula);
          setFormula(formattedText);
          setTextareaValue(formattedText);
        };

        const copyToClipboard = (formulaText) => {
          navigator.clipboard.writeText(formulaText)
            .then(() => {
              setStatus({ msg: "Copied to clipboard!", type: "valid" });
              setTimeout(() => renderFormula(formula), 1500);
            })
            .catch((err) => {
              // Fallback for environments where clipboard API is restricted
              const input = document.createElement("textarea");
              input.value = formulaText;
              document.body.appendChild(input);
              input.select();
              document.execCommand("copy");
              document.body.removeChild(input);
              setStatus({ msg: "Copied (Fallback)!", type: "valid" });
              setTimeout(() => renderFormula(formula), 1500);
            });
        };

        const handleTooltip = (e, funcName) => {
          if (e.target.classList.contains("token-function")) {
            const name = funcName.toUpperCase();
            const help = functionHelp[name];
            const tooltipEl = document.getElementById("tooltip");
            if (help) {
              tooltipEl.style.display = "block";
              // Keep tooltip position relative to the cursor
              tooltipEl.style.left = (e.clientX + 10) + "px";
              tooltipEl.style.top = (e.clientY + 10) + "px";
              tooltipEl.querySelector(".tooltip-title").innerText =
                name;
              tooltipEl.querySelector(".tooltip-syntax").innerText =
                help.syntax;
              tooltipEl.querySelector(".tooltip-desc").innerText =
                help.desc;
              return;
            }
          }
          document.getElementById("tooltip").style.display = "none";
        };

        const handleTooltipHide = () => {
          document.getElementById("tooltip").style.display = "none";
        };

        // --- History Logic ---

        const loadHistory = () => {
          const history = JSON.parse(
            localStorage.getItem("excel-history") || "[]",
          );
          setHistoryList(history);
        };

        const saveCurrent = () => {
          const trimmedFormula = formula.trim();
          if (!trimmedFormula) return;

          let history = JSON.parse(
            localStorage.getItem("excel-history") || "[]",
          );
          history.unshift({
            time: new Date().toLocaleString(),
            text: trimmedFormula,
          });
          if (history.length > 20) history.pop();

          localStorage.setItem(
            "excel-history",
            JSON.stringify(history),
          );
          setHistoryList(history);
          setStatus({ msg: "Saved to History", type: "valid" });
          setTimeout(() => renderFormula(formula), 1500); // revert status
        };

        const selectHistoryItem = (itemText) => {
          setFormula(itemText);
          setTextareaValue(itemText);
          setIsHistoryOpen(false);
        };

        const toggleHistory = () => {
          if (!isHistoryOpen) {
            loadHistory();
          }
          setIsHistoryOpen(!isHistoryOpen);
        };

        // --- Status Class Helper ---
        const getStatusClass = (type) => {
          if (type === "valid") return "status-valid";
          if (type === "error") return "status-error";
          return "";
        };

        // --- HTML Template (lit-html) ---
        return html`
          <header>
            <div class="brand">
              <h1>Excel Studio</h1>
              <div class="status-indicator ${getStatusClass(
                status.type,
              )}">${status.msg}</div>
            </div>
            <div class="toolbar">
              <button @click="${toggleTheme}">${isLight
                ? "â˜¾ Dark"
                : "â˜€ Light"}</button>
              <button @click="${toggleHistory}">ðŸ•’ History</button>
              <button @click="${minify}">Minify</button>
              <button class="primary" @click="${beautify}">Format</button>
            </div>
          </header>

          <div class="container">
            <div class="panel">
              <div class="panel-header">
                <span>Editor</span>
                <div style="display:flex; gap:10px;">
                  <button
                    style="border:none;background:none;color:#888;cursor:pointer;"
                    @click="${saveCurrent}"
                  >
                    ðŸ’¾ Save
                  </button>
                  <button
                    style="border:none;background:none;color:#888;cursor:pointer;"
                    @click="${() => copyToClipboard(formula)}"
                  >
                    ðŸ“‹ Copy
                  </button>
                </div>
              </div>
              <textarea
                .value="${textareaValue}"
                @input="${handleInput}"
                placeholder="Paste formula here... e.g. =IF(A1>0,SUM(B1:B10),&quot;Error&quot;)"
                spellcheck="false"
                autocomplete="off"
              ></textarea>
            </div>
            <div class="panel">
              <div class="panel-header">
                <span>Live Preview (Hover functions for help)</span>
              </div>
              <div id="output">${renderedHtml}</div>
            </div>
          </div>

          <!-- History Modal -->
          ${isHistoryOpen
            ? html`
              <div class="modal-overlay" @click="${(e) =>
                e.target.classList.contains("modal-overlay") &&
                toggleHistory()}">
                <div class="modal-content">
                  <div class="modal-header">
                    <h3 style="margin:0;color:var(--text-color)">Saved Formulas</h3>
                    <button
                      @click="${toggleHistory}"
                      style="background:none;border:none;font-size:1.2rem;cursor:pointer;color:var(--text-color)"
                    >
                      Ã—
                    </button>
                  </div>
                  <div class="modal-body">
                    ${historyList.length === 0
                      ? html`
                        <div style="padding:20px;text-align:center;color:#888">
                          No history found.
                        </div>
                      `
                      : historyList.map((item) =>
                        html`
                          <div class="history-item" @click="${() =>
                            selectHistoryItem(item.text)}">
                            <div class="history-time">${item.time}</div>
                            <div class="history-snippet">${escapeHtml(
                              item.text,
                            )}</div>
                          </div>
                        `
                      )}
                  </div>
                </div>
              </div>
            `
            : null}
        `;
      }

      // Define the Web Component, disabling Shadow DOM
      customElements.define(
        "excel-studio-app",
        component(ExcelStudioApp, { useShadowDOM: false }),
      );
    </script>
  </body>
</html>
