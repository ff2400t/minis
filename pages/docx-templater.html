<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel to Docx Templater</title>
    <script type="module" src="/components/app-layout.js"></script>
    <script src="https://unpkg.com/pizzip@3.1.4/dist/pizzip.js"></script>
    <script
      src="https://unpkg.com/docxtemplater@3.37.2/build/docxtemplater.js"
    ></script>
    <style>
      @import url("/unified-theme.css");
      
      textarea {
        min-height: 150px;
        resize: vertical;
        white-space: pre;
        overflow-x: auto;
      }

      .preview-table-container {
        overflow-x: auto;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        margin-top: 10px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        text-align: left;
        font-size: 0.9rem;
      }

      th, td {
        padding: 8px 12px;
        border-bottom: 1px solid var(--border-color);
        white-space: nowrap;
      }

      th {
        background-color: var(--table-header-bg);
        font-weight: 600;
      }

      code {
        background-color: rgba(0, 0, 0, 0.05);
        padding: 2px 4px;
        border-radius: 4px;
        font-family: monospace;
        color: var(--primary);
      }
    </style>
  </head>
  <body>
    <app-layout title="Docx Templater">
      <div id="app"></div>
    </app-layout>

    <script type="module">
      import { html, render } from "/vendor/lit-html.js";
      import "/components/status-message.js";

      // --- Helpers ---
      const toSnakeCase = (str) =>
        str &&
        str.match(
          /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g,
        )
          .map((x) => x.toLowerCase())
          .join("_");

      const parseData = (text) => {
        if (!text.trim()) {
          return { parsedData: [], headers: [], error: "" };
        }
        try {
          const rows = text.trim().split(/\r?\n/).map((row) =>
            row.split("\t")
          );
          if (rows.length < 2) {
            return {
              parsedData: [],
              headers: [],
              error: "Please paste at least two rows (header + data).",
            };
          }

          const headers = rows[0].map((h) => ({
            original: h,
            key: toSnakeCase(h),
          }));
          const parsedData = rows.slice(1).map((row) => {
            const obj = {};
            headers.forEach((h, i) => obj[h.key] = row[i] || "");
            return obj;
          });

          return { parsedData, headers, error: "" };
        } catch (err) {
          return {
            parsedData: [],
            headers: [],
            error: "Error parsing data: " + err.message,
          };
        }
      };

      const generateDocxZip = (
        templateContent,
        data,
        selectedColumn,
      ) => {
        const files = data.map((row, index) => {
          // Wrap ArrayBuffer in Uint8Array for PizZip compatibility
          const docZip = new PizZip(new Uint8Array(templateContent));
          const doc = new window.docxtemplater(docZip, {
            paragraphLoop: true,
            linebreaks: true,
          });
          doc.render(row);

          const content = doc.getZip().generate({
            type: "uint8array",
            mimeType:
              "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            compression: "DEFLATE",
          });

          let filename = "document_" + (index + 1);
          if (selectedColumn && row[selectedColumn]) {
            filename = row[selectedColumn].toString().replace(
              /[^a-z0-9]/gi,
              "_",
            );
          }
          return {
            name: filename + ".docx",
            content,
          };
        });

        const documents = new PizZip();
        const docFolder = documents.folder("documents");
        files.forEach((a) => docFolder.file(a.name, a.content));

        return documents.generate({ type: "blob" });
      };

      // --- State Management ---
      const initialState = {
        parsedData: [],
        headers: [],
        selectedColumn: "",
        templateFile: null,
        error: "",
        isGenerating: false,
        downloadUrl: "",
      };

      const reducer = (state, action) => {
        switch (action.type) {
          case "PASTE_DATA": {
            const { parsedData, headers, error } = parseData(
              action.value,
            );
            return {
              ...state,
              parsedData,
              headers,
              error,
              selectedColumn: headers[0]?.key || "",
              downloadUrl: "",
            };
          }
          case "FILE_SELECTED":
            return {
              ...state,
              templateFile: action.file,
              downloadUrl: "",
            };
          case "COLUMN_SELECTED":
            return { ...state, selectedColumn: action.value };
          case "START_GENERATION":
            return { ...state, isGenerating: true, error: "" };
          case "GENERATION_SUCCESS":
            return {
              ...state,
              isGenerating: false,
              downloadUrl: action.url,
            };
          case "GENERATION_ERROR":
            return {
              ...state,
              isGenerating: false,
              error: action.error,
            };
          default:
            return state;
        }
      };

      let state = initialState;

      const dispatch = (action) => {
        state = reducer(state, action);
        renderApp();
      };

      // --- Async Actions ---
      const handleGenerate = async () => {
        if (!state.templateFile || state.parsedData.length === 0) {
          return;
        }

        dispatch({ type: "START_GENERATION" });

        try {
          const reader = new FileReader();
          reader.readAsArrayBuffer(state.templateFile);
          reader.onload = (evt) => {
            try {
              const content = evt.target.result;
              const zipBlob = generateDocxZip(
                content,
                state.parsedData,
                state.selectedColumn,
              );
              const url = URL.createObjectURL(zipBlob);
              dispatch({ type: "GENERATION_SUCCESS", url });
            } catch (err) {
              console.error(err);
              dispatch({
                type: "GENERATION_ERROR",
                error: "Error processing template: " + err.message,
              });
            }
          };
          reader.onerror = () =>
            dispatch({
              type: "GENERATION_ERROR",
              error: "Error reading file.",
            });
        } catch (err) {
          dispatch({
            type: "GENERATION_ERROR",
            error: "Unexpected error: " + err.message,
          });
        }
      };

      // --- Views ---
      const dataPreview = (data, headers) =>
        html`
          <div class="form-group">
            <label>Data Preview (${data.length} rows)</label>
            <div class="preview-table-container">
              <table>
                <thead>
                  <tr>
                    ${headers.map((h) =>
                      html`
                        <th title="Template key: ${h.key}">
                          ${h.original}<br><small><code>{${h
                            .key}}</code></small>
                        </th>
                      `
                    )}
                  </tr>
                </thead>
                <tbody>
                  ${data.slice(0, 5).map((row) =>
                    html`
                      <tr>
                        ${headers.map((h) =>
                          html`
                            <td>${row[h.key]}</td>
                          `
                        )}
                      </tr>
                    `
                  )}
                </tbody>
              </table>
            </div>
            ${data.length > 5
              ? html`
                <p class="help-text">...and ${data.length -
                  5} more rows.</p>
              `
              : ""}
          </div>
        `;

      const appTemplate = (s) =>
        html`
          <div class="space-y-6">
            <div class="card">
              <p class="text-gray-500">
                Paste your Excel data (copy from Excel/Sheets), select a template,
                and generate individual .docx files.
              </p>
            </div>

            <div class="card space-y-6">
              <div class="form-group">
                <label class="label-tiny mb-2">1. Paste Data (Header row required)</label>
                <textarea
                  placeholder="Paste Excel data here..."
                  @input="${(e) =>
                    dispatch({
                      type: "PASTE_DATA",
                      value: e.target.value,
                    })}"
                ></textarea>
                ${s.error
                  ? html`
                    <status-message type="error" .message="${s.error}"></status-message>
                  `
                  : ""}
              </div>

              ${s.parsedData.length > 0
                ? html`
                  ${dataPreview(s.parsedData, s.headers)}

                  <div class="form-group">
                    <label class="label-tiny mb-2">2. Upload Docx Template</label>
                    <input type="file" accept=".docx" @change="${(e) =>
                      dispatch({
                        type: "FILE_SELECTED",
                        file: e.target.files[0],
                      })}">
                    <p class="help-text">
                      Use <code>{snake_case_header}</code> in your Word document.
                    </p>
                  </div>

                  <div class="form-group">
                    <label class="label-tiny mb-2">3. Select Filename Column</label>
                    <select .value="${s.selectedColumn}" @change="${(e) =>
                      dispatch({
                        type: "COLUMN_SELECTED",
                        value: e.target.value,
                      })}">
                      ${s.headers.map((h) =>
                        html`
                          <option value="${h.key}">${h.original} ({${h
                            .key}})</option>
                        `
                      )}
                    </select>
                  </div>

                  <div class="flex items-center gap-4">
                    <button
                      class="btn btn-primary"
                      @click="${handleGenerate}"
                      ?disabled="${!s.templateFile || s.isGenerating}"
                    >
                      ${s.isGenerating ? html`<div class="spinner border-white" style="width:1rem; height:1rem; border-width:2px;"></div> Generating...` : "Generate Zip"}
                    </button>

                    ${s.downloadUrl
                      ? html`
                        <a
                          href="${s.downloadUrl}"
                          download="generated_documents.zip"
                          class="btn btn-secondary text-primary font-bold"
                        >
                          Download ZIP
                        </a>
                      `
                      : ""}
                  </div>
                `
                : ""}
            </div>
          </div>
        `;

      const renderApp = () => {
        render(appTemplate(state), document.getElementById("app"));
      };

      renderApp();
    </script>
  </body>
</html>
