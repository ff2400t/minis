<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Data Extractor (Haunted Hooks)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load PDF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <style>
        .data-table {
            table-layout: fixed;
            width: 100%;
            border-collapse: collapse;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.875rem; /* text-sm */
        }
        .data-table td, .data-table th {
            border: 1px solid #e5e7eb;
            padding: 8px;
            text-align: left;
            word-break: break-word;
            white-space: normal;
        }
        .data-table tr:nth-child(even) {
            background-color: #f9fafb;
        }
        .file-row td {
            background-color: #bfdbfe !important; /* Blue-200 */
            font-weight: bold;
            color: #1e3a8a;
            border-top: 2px solid #3b82f6;
            font-size: 1rem;
        }
        .drag-active {
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
            transform: scale(1.01);
            transition: all 0.2s ease;
        }
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
        }
        .regex-scroll::-webkit-scrollbar {
            height: 6px;
        }
        .regex-scroll::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }
    </style>

    <script type="module">
        // Load haunted and its dependencies from CDN
        import { html, render } from 'https://unpkg.com/lit-html?module';
        import { component, useState, useEffect, useCallback, useMemo } from 'https://unpkg.com/haunted?module';

        // Set the workerSrc for PDF.js
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        }

        // --- CONSTANTS & GLOBALS ---
        const LOCAL_STORAGE_KEY = 'dataExtractorCustomParsers';
        
        const INITIAL_MODAL_STATE = {
            isOpen: false,
            fileName: '',
            passwordInput: '',
            useForSubsequent: false,
            fileToProcess: null, 
        };

        const BUILT_IN_PARSERS = [
            // [Name, Match Strings, Metadata Regex, Table Regex, Parser Function]
            [
                "GST Challan",
                ["GOODS AND SERVICES TAX PAYMENT RECEIPT"],
                /Name:\s+(?<Name>.*?)\s+Address.*?GSTIN:\s+(?<GSTIN>\w+).*?Date :\s+(?<Date>\d\d\/\d\d\/\d{4}).*?(?<StateCode>\d+)\s+(?<StateName>[^\d]+?)\s+SGST/s,
                /(?<name>\w+)\(.*?\)\s+(?<tax>-|\d+)\s+(?<interest>-|\d+)\s+(?<penalty>-|\d+)\s+(?<fees>-|\d+)\s+(?<others>-|\d+)\s+(?<total>-|\d+)\s+/g,
                (text, metaRx, tableRx) => {
                    const metadataFields = {};
                    const metaMatch = text.match(metaRx);
                    if (metaMatch && metaMatch.groups) {
                        Object.assign(metadataFields, metaMatch.groups);
                        if (metaMatch.groups.StateCode && metaMatch.groups.StateName) {
                            metadataFields.State = `${metaMatch.groups.StateCode} ${metaMatch.groups.StateName}`;
                            delete metadataFields.StateCode;
                            delete metadataFields.StateName;
                        }
                    }

                    const metadataRows = Object.entries(metadataFields).map(([k,v]) => [k, v, '', '', '', '', '']);
                    const matches = [...text.matchAll(tableRx)];
                    const headers = ['Head', 'Tax', 'Interest', 'Penalty', 'Fees', 'Others', 'Total'];
                    const dataRows = matches.map(m => [m.groups.name, m.groups.tax, m.groups.interest, m.groups.penalty, m.groups.fees, m.groups.others, m.groups.total]);
                    
                    const totalMatch = text.match(/Total Amount\s+([\d,]+)/);
                    if (totalMatch && !matches.find(m => m.groups.name === 'Total')) {
                        dataRows.push(['Grand Total', '-', '-', '-', '-', '-', totalMatch[1].replace(/,/g, '')]);
                    }
                    return { allRows: [...metadataRows, headers, ...dataRows], metadataFields };
                }
            ],
            [
                "GSTR-3B",
                ["Form GSTR-3B", "See rule 61(5)"],
                /Year (?<Year>[\d-]+)\s+Period\s+(.*)\s+GSTIN\s+of\s+the\s+supplier\s+(?<GSTIN>\w+)\s+2\(a\)\.\s+Legal\s+name\s+of\s+the\s+registered\s+person\s+(?<Name>.*)\s+2\(b\)/,
                /\([a-e]\s?\) (?!and)(.*?) (\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+/g,
                generalDocumentParser
            ],
            [
                "TDS",
                ["INCOME TAX DEPARTMENT", "Challan Receipt"],
                /Nature of Payment : (?<Section_No>\w+)\s+Amount \(in\s+Rs\.\) : ‚Çπ (?<Amount>\d[\d,.]*).*(?<Deposit_Date>\d\d\-\s?\w{3}-\d{4})/g,
                /Nature of Payment : (?<sectionNo>\w+)\s+Amount \(in\s+Rs\.\) : ‚Çπ (?<amt>\d[\d,.]*).*(?<depositDate>\d\d\-\s?\w{3}-\d{4})/g,
                generalDocumentParser
            ],
            [
                "Union Bank Statement",
                ["Union Bank of India", "Statement of Account"],
                /Statement of Account\s+(?<Account_Holder_Name>.*?)\s+.* Account No\s+(?<Account_Number>\d+)/is,
                /(?<date>\d\d-\d\d-\d{4})\s+\d\d:\d\d:\d\d\s+(?<particulars>.*?)\s+(?<amt>[\d,]+\.\d\s?\d)\s+(?<bal>-?\s?[\d,]+\.\d\s?\d)/g,
                generalDocumentParser
            ],
            [
                "Canara Bank Statement",
                ["Canara Bank does not"],
                /Account Number (?<Account_Number>\d+).* Opening Balance Rs\. (?<Opening_Balance>-?[\d,]+\.\d\d)\s+Closing Balance Rs\. (?<Closing_Balance>-?[\d,]+\.\d\d)/s,
                /\s\s(?<date>\d\d-\d\d-\d{4})\s+\d\d:\d\d:\d\d\s+(?<particulars>.*?)\s+(?<amt>[\d+,]+\.\d\d)\s+(?<bal>-?[\d+,]+\.\d\d)/g,
                generalDocumentParser
            ],
            [
                "RBL Bank Statement",
                ["RBL BANK LTD"],
                /Account Name: (?<Account_Name>.*?) Home Branch: .* in Account Number:\s+(?<Account_Number>\d+)\s+.* Opening Balance: ‚Çπ (?<Opening_Balance>[\d,]+\.\d{2})\s+Count Of Debit: \d+\s+Closing Balance: ‚Çπ (?<Closing_Balance>[\d,]+\.\d{2})/s,
                /(?<date>\d\d\/\d\d\/\d{4})\s+\d\d\/\d\d\/\d{4}\s+(?<particular>.*?)\s+(?<amt>[\d,]+\.\s?\d\s?\d)\s+(?<bal>[\d,]+\s?\.\s?\d\s?\d)/g,
                generalDocumentParser
            ],
            [
                "IDBI Bank Statement",
                ["IDBI Bank or other authorities"],
                /^(?<Name>.*?) Address .* A\/C NO: (?<AccNo>\d+)/s,
                /(?<date>\d\d\/\d\d\/\d{4})\s+(?<particular>.*?)\s+(?<type>Dr\.|Cr\.)\s+\w{3}\s+(?<Amt>[\d,]+\.\d{2})\s+\d\d\/\d\d\/\d{4}\s+\d\d:\d\d:\d\d\s+(?<serialNo>\d+)\s+(?<Bal>-?[\d,]+\.\d{2})/g,
                (text, metaRx, tableRx) => {
                    const metadataMatch = text.match(metaRx);
                    const metadataFields = {
                        'Account Name': metadataMatch?.groups?.Name?.trim() || 'N/A',
                        'Account Number': metadataMatch?.groups?.AccNo || 'N/A'
                    };
                    const metadataRows = Object.entries(metadataFields).map(([k,v]) => [k, v, '', '', '', '', '']);

                    const matches = [...text.matchAll(tableRx)];
                    const headers = ['Date', 'Particulars/Description', 'Type', 'Amount', 'Serial No', 'Balance', ''];
                    const dataRows = matches.map(m => {
                        const g = m.groups;
                        const amount = g.type === 'Dr.' ? `-${g.Amt}` : g.Amt;
                        return [g.date, g.particular.trim(), g.type, amount.replace(/,/g, ''), g.serialNo, g.Bal.replace(/,/g, ''), ''];
                    });
                    return { allRows: [...metadataRows, headers, ...dataRows], metadataFields };
                }
            ],
            [
                "PNB",
                [`Stk Stmt: Stock Statement` , `Trf: Transfer`],
                /Account Number (?<AccountNumber>\d+).*?Account Name: (?<Name>.*?) Customer Address/,
                /(?<TxnNo>[A-Z]{1}\d+) (?<date>\d\d\/\d\d\/\d{4}) (?<description>.*?) (?<Amt>-?\s?\d[\d,.\s]+\d) (?<bal>\d[\d,.\s]+\d) (?<Effect>Cr|Dr)/,
                generalDocumentParser,
            ],
            [
                "ICICI",
                ["PAN can be updated online or at the nearest ICICI Bank Branch ."],
                /^.*?  (?<Name>.*?)  .* (?<OpeningDate>\d\d-\d\d-\d{4}) B\/F (?<OpeningBalance>[\d,.]+)/,
                /(?<Date>\d\d-\d\d-\d{4}) (?<Particular>.*?) (?<Amount>[\d,]+\.\d\d) (?<Balance>[\d,.]+) /,
                generalDocumentParser
            ],
            [
                "PT Challan",
                ["CHALLAN MTR Form Number-6"],
                /Full Name (?<name>.*) Location.*From (?<period>.*) Flat.*TAX (?<amt>\d+\.\d{2}).*RBI Date (?<paymentDate>\d\d\/\d\d\/\d{4})/s,
                /(?<date>\d\d\/\d\d\/\d{4})\s+\d\d\/\d\d\/\d{4}\s+(?<particular>.*?)\s+(?<amt>[\d,]+\.\s?\d\s?\d)\s+(?<bal>[\d,]+\s?\.\s?\d\s?\d)/g,
                generalDocumentParser
            ],
            [
                "PF Challan Receipts",
                ["Payment Confirmation Receipt  TRRN No"],
                /ID : (?<Name>.*) Establishment Name.*\s(?<WageMonth>\w+-\d{4}) Wage Month : (?<Amt>\d[\d,.]*).*Payment Date : (?<PaymentDate>\d{2}-\w+-\d{4})/,
                generalDocumentParser
            ]
            [
               "PF Challan",
               "COMBINED CHALLAN OF A/C NO. 01, 02, 10, 21 & 22 (With EMPLOYEES' PROVIDENT FUND ORGANISATION",
                /(?<Month>\w+) (?<Year>\d{4}) (?<TRRN>\d{13}) (?<Name>.*) Total Subscribers .* (?<Amt>[\d,]+) Grand Total :/s,
                generalDocumentParser
            ]
        ];
        
        // --- Core Parser Function ---
        function generalDocumentParser(text, metadataRegex, tableRegex, fieldsToExtract) {
            let metadataRows = [];
            let metadataFields = {};
            
            // 1. Metadata Extraction
            if (metadataRegex) {
                try {
                    const metaMatch = text.match(metadataRegex);
                    if (metaMatch && metaMatch.groups) {
                        for (const [key, value] of Object.entries(metaMatch.groups)) {
                            const val = value ? value.trim() : '';
                            metadataFields[key] = val;
                            metadataRows.push([key, val, '', '', '', '', '']);
                        }
                    } else if (metaMatch) {
                        for (let i = 1; i < metaMatch.length; i++) {
                             const val = metaMatch[i] ? metaMatch[i].trim() : '';
                             const key = fieldsToExtract && fieldsToExtract[i-1] ? fieldsToExtract[i-1] : `Meta ${i}`;
                             metadataFields[key] = val;
                             metadataRows.push([key, val, '', '', '', '', '']);
                        }
                    }
                } catch (e) { console.error("Metadata Regex Error", e); }
            }

            // 2. Table Extraction
            let headers = [];
            let dataRows = [];
            
            if (tableRegex) {
                try {
                    const effectiveTableRegex = typeof tableRegex === 'string' ? new RegExp(tableRegex, 'g') : tableRegex;
                    
                    const matches = [...text.matchAll(effectiveTableRegex)];
                    if (matches.length > 0) {
                        const firstMatch = matches[0];
                        if (firstMatch.groups) {
                            headers = Object.keys(firstMatch.groups).map(k => k.charAt(0).toUpperCase() + k.slice(1).replace(/_/g, ' '));
                        } else {
                            headers = Array.from({length: firstMatch.length - 1}, (_, i) => `Col ${i+1}`);
                        }
                        
                        while (headers.length < 7) headers.push('');
                        if (headers.length > 7) headers = headers.slice(0, 7);

                        dataRows = matches.map(m => {
                            let row = [];
                            if (m.groups) row = Object.values(m.groups).map(val => val ? val.trim().replace(/,/g, '') : '');
                            else row = m.slice(1).map(val => val ? val.trim().replace(/,/g, '') : '');
                            
                            while (row.length < 7) row.push('');
                            return row.slice(0, 7);
                        });
                    }
                } catch (e) { console.error("Table Regex Error", e); }
            }

            return { allRows: [...metadataRows, headers, ...dataRows], metadataFields };
        }

        // --- Utility Functions ---

        function parseConfigBlock(text) {
            const getValue = (key, nextKeys) => {
                const lowerText = text.toLowerCase();
                const keyIndex = lowerText.indexOf(key.toLowerCase());
                
                if (keyIndex === -1) return null;
                
                const contentStart = keyIndex + key.length;
                let endIndex = text.length;
                
                nextKeys.forEach(nk => {
                    const nkIndex = lowerText.indexOf(nk.toLowerCase(), contentStart);
                    if (nkIndex !== -1 && nkIndex < endIndex) {
                        endIndex = nkIndex;
                    }
                });
                
                let val = text.substring(contentStart, endIndex).trim();
                if (val.endsWith(',')) val = val.slice(0, -1).trim(); 
                return val;
            };

            const keys = ['Name:', 'matchstring:', 'Metadata:', 'Table:'];
            const name = getValue('Name:', keys.filter(k => k !== 'Name:'));
            const matchString = getValue('matchstring:', keys.filter(k => k !== 'matchstring:'));
            const metadataRegex = getValue('Metadata:', keys.filter(k => k !== 'Metadata:'));
            const tableRegex = getValue('Table:', keys.filter(k => k !== 'Table:'));

            return { name, matchString, metadataRegex, tableRegex };
        }

        function generateConsolidatedTables(metadataList) {
            const groups = {};
            metadataList.forEach(item => {
                if (!groups[item.docType]) groups[item.docType] = [];
                groups[item.docType].push(item);
            });

            return Object.keys(groups).map(type => {
                const items = groups[type];
                const keys = new Set();
                items.forEach(i => Object.keys(i.fields).forEach(k => keys.add(k)));
                const header = Array.from(keys);
                
                const rows = items.map(item => {
                    const rowData = [item.fileName];
                    header.forEach(h => {
                        rowData.push(item.fields[h] || '');
                    });
                    return rowData;
                });

                return {
                    title: type,
                    headers: ['Source File', ...header],
                    rows: rows
                };
            });
        }
        
        class PasswordRequiredError extends Error {
            constructor(message) {
                super(message);
                this.name = 'PasswordException';
            }
        }

        async function extractAllPdfText(file, password = "") {
            const fileReader = new FileReader();
            return new Promise((resolve, reject) => {
                fileReader.onload = async function() {
                    const typedarray = new Uint8Array(this.result);
                    try {
                        const pdf = await pdfjsLib.getDocument({ data: typedarray, password: password }).promise;
                        let fullText = '';
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            fullText += textContent.items.map(item => item.str).join(' ') + ' '; 
                        }
                        resolve(fullText);
                    } catch (error) { 
                        if (error.name === 'PasswordException' || error.message.includes('password')) {
                            reject(new PasswordRequiredError("Password required or incorrect."));
                        } else {
                            reject(error);
                        }
                    }
                };
                fileReader.onerror = () => reject(new Error("Error reading file."));
                fileReader.readAsArrayBuffer(file);
            });
        }
        
        // --- Haunted Component (Main Application) ---

        function App() {
            // --- State Declarations ---
            const [customParsers, setCustomParsers] = useState([]);
            const [isDragging, setIsDragging] = useState(false);
            const [fileSummary, setFileSummary] = useState('');
            const [status, setStatus] = useState({ message: '', type: '' });
            const [isParserFormVisible, setIsParserFormVisible] = useState(false);
            const [isParserListModalVisible, setIsParserListModalVisible] = useState(false);
            const [expandedParsers, setExpandedParsers] = useState({});
            const [isTemplatesModalVisible, setIsTemplatesModalVisible] = useState(false);
            const [templatesText, setTemplatesText] = useState('');

            // Results State
            const [allRows, setAllRows] = useState([]);
            const [rawText, setRawText] = useState('');
            const [consolidatedMetadata, setConsolidatedMetadata] = useState([]);
            const [isResultVisible, setIsResultVisible] = useState(false);
            const [isTableVisible, setIsTableVisible] = useState(true);
            const [isRawTextVisible, setIsRawTextVisible] = useState(false);
            const [isConsolidatedVisible, setIsConsolidatedVisible] = useState(false);
            
            // Password State
            const [passwordModal, setPasswordModal] = useState(INITIAL_MODAL_STATE);
            const [savedPassword, setSavedPassword] = useState(null);
            
            // File Processing Context (Mutable, non-reactive state managed internally)
            const fileProcessingContext = useMemo(() => ({
                fileList: [],
                currentIndex: 0,
                tempAllRows: [],
                tempRawText: '',
                tempMetadata: [],
                successCount: 0,
            }), []);
            
            const consolidatedTables = useMemo(() => generateConsolidatedTables(consolidatedMetadata), [consolidatedMetadata]);

            // --- Effects ---

            // Load custom parsers on mount
            useEffect(() => {
                try {
                    const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
                    if (stored) {
                        const parsers = JSON.parse(stored);
                        if (Array.isArray(parsers)) {
                            setCustomParsers(parsers);
                        }
                    }
                } catch (e) {
                    console.error("Could not load custom parsers from localStorage:", e);
                }
            }, []);

            // --- Handlers (Memoized) ---
            
            const saveCustomParsers = useCallback((parsers) => {
                try {
                    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(parsers));
                    setCustomParsers(parsers);
                } catch (e) {
                    console.error("Could not save custom parsers to localStorage:", e);
                }
            }, []);
            
            const addCustomParser = useCallback((configText) => {
                const data = parseConfigBlock(configText);

                const { name, matchString, metadataRegex, tableRegex } = data;

                if (!name || !matchString) {
                    setStatus({ message: "Parser Name (Name:) and Match Strings (matchstring:) are required.", type: 'error' });
                    return;
                }

                try {
                    if (metadataRegex) new RegExp(metadataRegex, 's');
                    if (tableRegex) new RegExp(tableRegex, 'g');
                } catch (e) {
                    setStatus({ message: `Invalid Regex: ${e.message}`, type: 'error' });
                    return;
                }

                const newParser = {
                    name,
                    matchString: matchString.split(',').map(s => s.trim()).filter(s => s.length > 0), 
                    metadataRegex: metadataRegex || '',
                    tableRegex: tableRegex || ''
                };
                
                if (newParser.matchString.length === 0) {
                    setStatus({ message: "The matchstring: value cannot be empty.", type: 'error' });
                    return;
                }

                const currentParsers = [...customParsers];
                const existingIndex = currentParsers.findIndex(p => p.name === name);

                let newParserList;
                let action;

                if (existingIndex !== -1) {
                    currentParsers[existingIndex] = newParser;
                    newParserList = currentParsers;
                    action = "updated";
                } else {
                    newParserList = [...currentParsers, newParser];
                    action = "added";
                }

                saveCustomParsers(newParserList);
                setIsParserFormVisible(false);
                setStatus({ message: `Custom parser "${name}" successfully ${action}!`, type: 'success' });
            }, [customParsers, saveCustomParsers]);

            const removeCustomParser = useCallback((index) => {
                const name = customParsers[index].name;
                const current = [...customParsers];
                current.splice(index, 1);
                saveCustomParsers(current);
                setStatus({ message: `Custom parser "${name}" removed.`, type: 'info' });
            }, [customParsers, saveCustomParsers]);

            const copyTable = useCallback((tableId) => {
                const table = document.getElementById(tableId);
                if (!table) return;
                const rows = Array.from(table.rows).map(row => 
                    Array.from(row.cells).map(cell => cell.innerText).join('\t')
                ).join('\n');
                const tempTextArea = document.createElement('textarea');
                tempTextArea.style.position = 'fixed';
                tempTextArea.style.opacity = '0';
                tempTextArea.value = rows;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                try {
                    document.execCommand('copy');
                    setStatus({ message: "Table content copied to clipboard!", type: 'success' });
                } catch (err) {
                    setStatus({ message: "Manual copy required.", type: 'error' });
                } finally {
                    document.body.removeChild(tempTextArea);
                    setTimeout(() => setStatus({ message: '', type: '' }), 3000);
                }
            }, []);

            // --- File Processing Logic ---

            const finalizeProcessing = useCallback(() => {
                const { tempAllRows, tempMetadata, tempRawText, successCount, fileList } = fileProcessingContext;
                
                setAllRows(tempAllRows);
                setRawText(tempRawText);
                setConsolidatedMetadata(tempMetadata);
                setIsResultVisible(true);
                
                if (tempAllRows.length === 0 && tempMetadata.length === 0) {
                    setStatus({ message: "Processed files but found no recognized data.", type: 'info' });
                } else {
                    setStatus({ message: `Successfully processed ${successCount} of ${fileList.length} files!`, type: 'success' });
                }
            }, [fileProcessingContext]);


            const processFileContent = useCallback(async (file, password) => {
                let rawText = await extractAllPdfText(file, password);
                rawText = rawText.replace(/   /g, ' '); 
                
                let parsedData = { allRows: [], metadataFields: {} };
                let docType = "Unknown";
                const cleanCheckText = rawText.replace(/\s+/g, ' ');

                let parserFound = false;

                const allParsers = [...customParsers.map(p => [p.name + " (Custom)", p.matchString, p.metadataRegex, p.tableRegex, generalDocumentParser]), ...BUILT_IN_PARSERS];

                for (const [name, matches, metaRx, tableRx, parserFn] of allParsers) {
                    const isMatch = matches.some(s => cleanCheckText.toLowerCase().includes(s.toLowerCase()));
                    if (isMatch) {
                        docType = name;
                        
                        let effectiveMetaRx = typeof metaRx === 'string' ? new RegExp(metaRx, 's') : metaRx;
                        let effectiveTableRx = typeof tableRx === 'string' ? new RegExp(tableRx, 'g') : tableRx;

                        parsedData = parserFn(rawText, effectiveMetaRx, effectiveTableRx);
                        parserFound = true;
                        break;
                    }
                }
                
                // Update context with the successfully parsed data
                fileProcessingContext.tempRawText += `\n--- SOURCE: ${file.name} (${docType}) ---\n${rawText}\n`;

                if (parserFound) {
                    if (parsedData.metadataFields && Object.keys(parsedData.metadataFields).length > 0) {
                        fileProcessingContext.tempMetadata.push({
                            fileName: file.name,
                            docType: docType,
                            fields: parsedData.metadataFields
                        });
                    }

                    const fileLabelRow = [`Source: ${file.name} (${docType})`, '', '', '', '', '', ''];
                    if (fileProcessingContext.tempAllRows.length > 0) fileProcessingContext.tempAllRows.push(['', '', '', '', '', '', '']); 
                    fileProcessingContext.tempAllRows.push(fileLabelRow);
                    fileProcessingContext.tempAllRows.push(...parsedData.allRows);
                }
                
                if (!parserFound) {
                    throw new Error("Document type unknown. Data not extracted.");
                }
            }, [customParsers, fileProcessingContext]);


            const processNextFile = useCallback(async () => {
                const { fileList, currentIndex } = fileProcessingContext;
                
                if (currentIndex >= fileList.length) {
                    finalizeProcessing();
                    return;
                }

                const file = fileList[currentIndex];
                setStatus({ message: `Processing ${currentIndex + 1} of ${fileList.length}: ${file.name}...`, type: 'info' });
                
                try {
                    await processFileContent(file, savedPassword || "");
                    
                    fileProcessingContext.successCount++;
                    fileProcessingContext.currentIndex++;
                    processNextFile();

                } catch (e) {
                    if (e.name === 'PasswordException') {
                        // PAUSE: Open modal
                        setPasswordModal(prev => ({
                            ...prev,
                            isOpen: true,
                            fileName: file.name,
                            fileToProcess: file,
                            passwordInput: ''
                        }));
                        return; 
                    }
                    
                    // Other Error
                    console.error(`Error processing ${file.name}:`, e);
                    fileProcessingContext.tempRawText += `\n--- SOURCE: ${file.name} (FAILED) ---\nError: ${e.message}\n`;
                    fileProcessingContext.currentIndex++;
                    processNextFile();
                }
            }, [fileProcessingContext, processFileContent, savedPassword, finalizeProcessing]);


            const processFiles = useCallback((fileList) => {
                if (!fileList || fileList.length === 0) {
                    setFileSummary('');
                    setIsResultVisible(false);
                    setStatus({ message: '', type: '' });
                    return;
                }

                const files = Array.from(fileList).filter(f => f.type === 'application/pdf');
                const count = files.length;
                setFileSummary(count === 1 ? `File: ${files[0].name}` : `${count} files selected`);
                
                // Reset UI state
                setIsResultVisible(false);
                setAllRows([]);
                setRawText('');
                setConsolidatedMetadata([]);
                setSavedPassword(null);
                
                // Reset mutable context
                Object.assign(fileProcessingContext, {
                    fileList: files,
                    currentIndex: 0,
                    tempAllRows: [],
                    tempRawText: '',
                    tempMetadata: [],
                    successCount: 0,
                });

                processNextFile();
            }, [fileProcessingContext, processNextFile]);


            const handlePasswordSubmit = useCallback(async () => {
                const { fileToProcess, passwordInput, useForSubsequent } = passwordModal;
                const password = passwordInput;
                const useSubsequent = useForSubsequent;

                if (password.length === 0) {
                     setStatus({ message: "Please enter a password.", type: 'error' });
                     return;
                }
                
                // 1. Close modal and set saved password
                setPasswordModal(INITIAL_MODAL_STATE);
                setSavedPassword(useSubsequent ? password : null);
                setStatus({ message: '', type: '' });
                
                // 2. Attempt to re-process the file with the new password
                if (fileToProcess) {
                    try {
                        await processFileContent(fileToProcess, password); 
                        
                        fileProcessingContext.successCount++;
                        fileProcessingContext.currentIndex++;
                        processNextFile(); 

                    } catch (e) {
                        if (e.name === 'PasswordException') {
                            setStatus({ message: "Incorrect password. Please try again.", type: 'error' });
                            setPasswordModal(prev => ({
                                ...prev,
                                isOpen: true,
                                fileName: fileToProcess.name,
                                fileToProcess: fileToProcess,
                                passwordInput: password
                            }));
                            return; 
                        }
                        
                        // Other error: log and skip this file, continue the main loop
                        console.error("Error after password retry:", e);
                        fileProcessingContext.currentIndex++;
                        processNextFile(); 
                    }
                }
            }, [passwordModal, fileProcessingContext, processFileContent, processNextFile]);

            const handlePasswordSkip = useCallback(() => {
                setPasswordModal(INITIAL_MODAL_STATE);
                setStatus({ message: '', type: '' }); 

                if (fileProcessingContext.fileList.length > fileProcessingContext.currentIndex) {
                    fileProcessingContext.tempRawText += `\n--- SOURCE: ${fileProcessingContext.fileList[fileProcessingContext.currentIndex].name} (SKIPPED BY USER) ---\n\n`;
                }
                fileProcessingContext.currentIndex++;
                processNextFile();
            }, [fileProcessingContext, processNextFile]);
            
            // --- Drag/Drop Handlers ---
            const handleDragOver = useCallback((e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(true); }, []);
            const handleDragLeave = useCallback((e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); }, []);
            const handleDrop = useCallback((e) => { 
                e.preventDefault(); e.stopPropagation(); setIsDragging(false); 
                const files = e.dataTransfer ? e.dataTransfer.files : null; 
                if (files && files.length > 0) processFiles(files);
            }, [processFiles]);
            
            const handleFileInput = useCallback((e) => { processFiles(e.target.files); }, [processFiles]);


            // --- Modal/UI Render Helpers ---

            const renderStatus = () => {
                if (!status.message) return html``;
                const baseClass = status.type === 'error' ? 'bg-red-100 text-red-800' : (status.type === 'success' ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800');
                return html`
                    <div class="p-4 rounded-lg text-sm mb-6 ${baseClass}" role="alert">
                        ${status.message}
                    </div>
                `;
            };

            const renderParserForm = () => {
                const customParsersHtml = customParsers.length > 0 ? html`
                    <div class="mb-6 p-4 bg-indigo-50 rounded-lg border border-indigo-100">
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="font-bold text-indigo-800">Active Custom Parsers:</h4>
                            <button 
                                @click=${() => {
                                    const text = customParsers.map(p => {
                                        return `Name: ${p.name}\nmatchstring: ${p.matchString.join(', ')}\nMetadata: ${p.metadataRegex || ''}\nTable: ${p.tableRegex || ''}`;
                                    }).join('\n\n---\n\n');
                                    setTemplatesText(text);
                                    setIsTemplatesModalVisible(true);
                                }}
                                class="text-xs bg-indigo-600 text-white px-2 py-1 rounded hover:bg-indigo-700 transition"
                            >
                                Edit / Export All
                            </button>
                        </div>
                        <ul class="space-y-2">
                            ${customParsers.map((p, i) => html`
                                <li class="flex justify-between items-center bg-white p-2 rounded shadow-sm">
                                    <div>
                                        <span class="font-semibold text-gray-800">${p.name}</span>
                                        <span class="text-xs text-gray-500 ml-2">(Match: ${p.matchString.join(', ')})</span>
                                    </div>
                                    <button @click=${() => removeCustomParser(i)} class="text-red-500 hover:text-red-700 text-sm font-medium px-2">Remove</button>
                                </li>
                            `)}
                        </ul>
                    </div>
                ` : html``;

                const submitForm = (e) => {
                    e.preventDefault();
                    const configInput = document.querySelector('#configTextInput');
                    if (configInput) addCustomParser(configInput.value);
                    configInput.value = ''; // Clear input after submission
                };

                return html`
                    <div class="mb-6 border rounded-lg overflow-hidden">
                        <button 
                            class="w-full text-left px-6 py-4 bg-gray-100 font-semibold text-gray-700 hover:bg-gray-200 flex justify-between items-center transition"
                            @click=${() => setIsParserFormVisible(!isParserFormVisible)}
                        >
                            <span>üõ†Ô∏è Configure Custom Parser (Add/Update/Import)</span>
                            <span>${isParserFormVisible ? '‚ñ≤' : '‚ñº'}</span>
                        </button>
                        ${isParserFormVisible ? html`
                            <div class="p-6 bg-white border-t">
                                ${customParsersHtml}

                                <form @submit=${submitForm}>
                                    <div class="mb-6">
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Quick Import (Paste Config Block)</label>
                                        <textarea 
                                            id="configTextInput"
                                            class="w-full h-48 rounded-md border-gray-300 shadow-sm border p-2 text-sm font-mono focus:ring-blue-500 focus:border-blue-500"
                                            placeholder="Define your parser here using the required keys.&#10;&#10;Name: My Custom Bank Statement&#10;matchstring: Bank Statement, Account Summary, MyBankCorp&#10;Metadata: /Account Number: (?<AccNo>\\d+).*?Name: (?<Name>.*?)/s&#10;Table: /(?<Date>\\d{2}\\.\\d{2}\\.\\d{4})\\s+.*\\s+(?<Amount>\\d+)/g"
                                        ></textarea>
                                        <p class="text-xs text-gray-500 mt-1">
                                            Define your parser using the keys: <code class="font-semibold">Name:</code>, <code class="font-semibold">matchstring:</code> (comma-separated document identifiers), <code class="font-semibold">Metadata:</code> (single-match regex for key info), and <code class="font-semibold">Table:</code> (global-match regex for rows).
                                        </p>
                                    </div>

                                    <button 
                                        type="submit"
                                        class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition font-medium"
                                    >
                                        Add / Update Parser
                                    </button>
                                </form>
                            </div>
                        ` : html``}
                    </div>
                `;
            };

            const renderConsolidatedSummary = () => {
                if (!isConsolidatedVisible || consolidatedTables.length === 0) return html``;

                return html`
                    <div class="mt-8 border-t pt-8">
                        <h2 class="text-2xl font-bold text-gray-800 mb-4">Consolidated Metadata Summary</h2>
                        <p class="text-gray-600 mb-4">A combined view of metadata across all processed files, grouped by document type.</p>
                        ${consolidatedTables.map((tbl, i) => html`
                            <div class="mb-8">
                                <div class="flex justify-between items-center mb-3">
                                    <h3 class="text-lg font-semibold text-blue-700">${tbl.title}</h3>
                                    <button @click=${() => copyTable(`consTable-${i}`)} class="px-3 py-1 bg-blue-100 text-blue-700 hover:bg-blue-200 rounded text-sm font-bold transition">
                                        Copy Table
                                    </button>
                                </div>
                                <div class="overflow-x-auto border rounded-lg shadow-sm">
                                    <table id=${`consTable-${i}`} class="data-table">
                                        <thead class="bg-gray-50">
                                            <tr>
                                                ${tbl.headers.map(h => html`<th class="font-bold text-gray-600">${h}</th>`)}
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${tbl.rows.map(row => html`
                                                <tr>
                                                    ${row.map(cell => html`<td>${cell}</td>`)}
                                                </tr>
                                            `)}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        `)}
                    </div>
                `;
            };

            const renderDetailedTable = () => {
                if (!isTableVisible) return html`
                    <div class="p-8 text-center text-gray-500 border rounded-lg bg-white mt-6">The extracted data table is currently hidden.</div>
                `;

                return html`
                    <div class="mt-6">
                        <h3 class="text-lg font-bold text-gray-700 mb-2">Detailed Extraction</h3>
                        <div class="overflow-x-auto border rounded-lg">
                            <table id="outputTable" class="data-table">
                                <tbody>
                                    ${allRows.map((row) => {
                                        const isSourceHeader = row[0] && row[0].startsWith('Source:');
                                        const rowClass = isSourceHeader ? 'file-row' : '';
                                        
                                        return html`
                                            <tr class=${rowClass}>
                                                ${row.map(cell => html`<td>${cell}</td>`)}
                                            </tr>
                                        `;
                                    })}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            };

            const renderPasswordModal = () => {
                if (!passwordModal.isOpen) return html``;
                
                const updatePassInput = (e) => {
                    const useForSubsequent = document.querySelector('#useForSubsequent').checked;
                    setPasswordModal(prev => ({ ...prev, passwordInput: e.target.value, useForSubsequent }));
                };

                const updateCheckbox = (e) => {
                    const passwordInput = document.querySelector('#passwordInput').value;
                    setPasswordModal(prev => ({ ...prev, passwordInput, useForSubsequent: e.target.checked }));
                };

                return html`
                    <div class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
                            <h3 class="text-xl font-bold text-gray-800 mb-4">Password Required</h3>
                            <p class="text-sm text-gray-600 mb-2">
                                The file <span class="font-bold text-blue-600">${passwordModal.fileName}</span> is encrypted.
                            </p>
                            
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-1">Enter Password</label>
                                <input 
                                    type="password" 
                                    id="passwordInput"
                                    class="w-full border border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                    placeholder="Password"
                                    .value=${passwordModal.passwordInput}
                                    @input=${updatePassInput}
                                    @keydown=${(e) => { if (e.key === 'Enter') handlePasswordSubmit(); }}
                                />
                            </div>

                            <div class="flex items-center mb-6">
                                <input 
                                    type="checkbox" 
                                    id="useForSubsequent"
                                    class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                                    ?checked=${passwordModal.useForSubsequent}
                                    @change=${updateCheckbox}
                                />
                                <label for="useForSubsequent" class="ml-2 block text-sm text-gray-700">
                                    Use this password for subsequent files
                                </label>
                            </div>

                            <div class="flex justify-end space-x-3">
                                <button 
                                    @click=${handlePasswordSkip}
                                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium text-sm transition"
                                >
                                    Skip File
                                </button>
                                <button 
                                    @click=${handlePasswordSubmit}
                                    class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium text-sm transition"
                                >
                                    Decrypt & Extract
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            };

            const renderParserListModal = () => {
                if (!isParserListModalVisible) return html``;

                const builtInParsersHtml = BUILT_IN_PARSERS.map((parser, idx) => {
                    const id = `builtin-${idx}`;
                    const name = parser[0];
                    const matchStrings = parser[1];
                    const metaRegex = parser[2];
                    const tableRegex = parser[3];
                    const isExpanded = expandedParsers[id];
                    
                    return html`
                        <li class="border rounded-lg p-3 bg-gray-50">
                            <div class="flex justify-between items-center">
                                <div>
                                    <span class="font-bold text-gray-800 block">${name}</span>
                                    <span class="text-xs text-gray-500">Matches: ${matchStrings.join(', ')}</span>
                                </div>
                                <button 
                                    @click=${() => setExpandedParsers(p => ({ ...p, [id]: !p[id] }))}
                                    class="text-blue-600 hover:text-blue-800 text-xs font-semibold px-2 py-1 border border-blue-200 rounded hover:bg-blue-50 transition"
                                >
                                    ${isExpanded ? 'Hide Regex' : 'Show Regex'}
                                </button>
                            </div>
                            ${isExpanded ? html`
                                <div class="mt-3 text-xs font-mono bg-white p-2 rounded border border-gray-200 regex-scroll overflow-x-auto">
                                    <div class="mb-2">
                                        <strong class="text-purple-700">Metadata Regex:</strong><br/>
                                        <span class="text-gray-700">${metaRegex ? metaRegex.toString() : 'N/A'}</span>
                                    </div>
                                    <div>
                                        <strong class="text-teal-700">Table Regex:</strong><br/>
                                        <span class="text-gray-700">${tableRegex ? tableRegex.toString() : 'N/A'}</span>
                                    </div>
                                </div>
                            ` : html``}
                        </li>
                    `;
                });

                const customParsersHtml = customParsers.length > 0 ? html`
                    <h4 class="text-sm font-bold text-gray-500 uppercase tracking-wide mb-2 mt-6">Custom Parsers</h4>
                    <ul class="space-y-2">
                        ${customParsers.map((parser, idx) => {
                            const id = `custom-${idx}`;
                            const isExpanded = expandedParsers[id];
                            
                            return html`
                                <li class="border rounded-lg p-3 bg-indigo-50 border-indigo-100">
                                    <div class="flex justify-between items-center">
                                        <div>
                                            <span class="font-bold text-indigo-900 block">${parser.name}</span>
                                            <span class="text-xs text-indigo-600">Matches: ${parser.matchString.join(', ')}</span>
                                        </div>
                                        <button 
                                            @click=${() => setExpandedParsers(p => ({ ...p, [id]: !p[id] }))}
                                            class="text-indigo-600 hover:text-indigo-800 text-xs font-semibold px-2 py-1 border border-indigo-200 rounded hover:bg-indigo-100 transition"
                                        >
                                            ${isExpanded ? 'Hide Regex' : 'Show Regex'}
                                        </button>
                                    </div>
                                    ${isExpanded ? html`
                                        <div class="mt-3 text-xs font-mono bg-white p-2 rounded border border-gray-200 regex-scroll overflow-x-auto">
                                            <div class="mb-2">
                                                <strong class="text-purple-700">Metadata Regex:</strong><br/>
                                                <span class="text-gray-700">${parser.metadataRegex || 'N/A'}</span>
                                            </div>
                                            <div>
                                                <strong class="text-teal-700">Table Regex:</strong><br/>
                                                <span class="text-gray-700">${parser.tableRegex || 'N/A'}</span>
                                            </div>
                                        </div>
                                    ` : html``}
                                </li>
                            `;
                        })}
                    </ul>
                ` : html``;


                return html`
                    <div class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-3xl mx-4 flex flex-col max-h-[90vh]">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-xl font-bold text-gray-800">Available Parsers</h3>
                                <button 
                                    @click=${() => setIsParserListModalVisible(false)}
                                    class="text-gray-500 hover:text-gray-700"
                                >
                                    ‚úï
                                </button>
                            </div>
                            
                            <div class="flex-grow overflow-y-auto pr-2">
                                <h4 class="text-sm font-bold text-gray-500 uppercase tracking-wide mb-2">Built-in Parsers</h4>
                                <ul class="space-y-2 mb-6">
                                    ${builtInParsersHtml}
                                </ul>

                                ${customParsersHtml}
                            </div>

                            <div class="mt-4 pt-4 border-t flex justify-end">
                                <button 
                                    @click=${() => setIsParserListModalVisible(false)}
                                    class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 font-medium text-sm transition"
                                >
                                    Close
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            };
            
            const renderTemplatesModal = () => {
                if (!isTemplatesModalVisible) return html``;

                const saveTemplates = () => {
                    const raw = document.querySelector('#templatesTextarea').value;
                    let blocks = [];
                    if (raw.includes('---')) {
                        blocks = raw.split('---');
                    } else {
                        blocks = raw.split(/\n\s*\n/);
                    }

                    const newParsers = [];
                    for (const block of blocks) {
                        const cleanBlock = block.trim();
                        if (!cleanBlock) continue;
                        const data = parseConfigBlock(cleanBlock);
                        
                        if (data.name && data.matchString) {
                            newParsers.push({
                                name: data.name,
                                matchString: data.matchString.split(',').map(s => s.trim()).filter(s => s.length > 0),
                                metadataRegex: data.metadataRegex || '',
                                tableRegex: data.tableRegex || ''
                            });
                        }
                    }

                    saveCustomParsers(newParsers);
                    setIsTemplatesModalVisible(false);
                    setTemplatesText('');
                    setStatus({ message: `Updated ${newParsers.length} custom parsers.`, type: 'success' });
                };

                return html`
                    <div class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-2xl mx-4 flex flex-col max-h-[90vh]">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-xl font-bold text-gray-800">Manage All Custom Parsers</h3>
                                <button 
                                    @click=${() => setIsTemplatesModalVisible(false)}
                                    class="text-gray-500 hover:text-gray-700"
                                >
                                    ‚úï
                                </button>
                            </div>
                            <p class="text-sm text-gray-600 mb-4">Edit all parsers below or paste a list to import multiple. Separate parsers with <code class="font-mono">---</code> or two blank lines.</p>
                            
                            <textarea 
                                id="templatesTextarea"
                                class="flex-grow w-full border border-gray-300 rounded-lg p-3 font-mono text-xs mb-4 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                rows="15"
                                .value=${templatesText}
                                @input=${(e) => setTemplatesText(e.target.value)}
                            ></textarea>

                            <div class="flex justify-end space-x-3">
                                <button 
                                    @click=${() => setIsTemplatesModalVisible(false)}
                                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium text-sm transition"
                                >
                                    Cancel
                                </button>
                                <button 
                                    @click=${saveTemplates}
                                    class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium text-sm transition"
                                >
                                    Save All Changes
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            };


            // --- Main Render Function (Lit-HTML Template) ---
            return html`
                <div class="container mx-auto bg-white shadow-xl rounded-xl p-6 md:p-10 relative">
                    <h1 class="text-3xl font-extrabold text-blue-800 mb-2">
                        Universal Data Extractor
                    </h1>
                    <p class="text-gray-600 mb-6">
                        Supports <strong>GST</strong>, <strong>Income Tax</strong>, and various <strong>Bank Statements</strong>.
                        <br>Drag & drop PDFs or define your own <strong>Custom Parser</strong> below.
                    </p>

                    ${renderParserForm()}

                    <div class="mb-6 flex justify-end">
                        <button 
                            @click=${() => setIsParserListModalVisible(true)}
                            class="text-sm bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg shadow flex items-center transition"
                        >
                            <span>‚ÑπÔ∏è Show Available Parsers</span>
                        </button>
                    </div>

                    <!-- Drop Zone -->
                    <label 
                        for="fileInput"
                        class="mb-8 p-10 border-2 border-dashed rounded-lg bg-blue-50 transition-all duration-200 flex flex-col items-center justify-center text-center cursor-pointer block border-blue-300 ${isDragging ? 'drag-active' : ''}"
                        @dragover=${handleDragOver}
                        @dragleave=${handleDragLeave}
                        @drop=${handleDrop}
                    >
                        <svg class="w-12 h-12 text-blue-500 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                        
                        <span class="block text-lg font-medium text-blue-700 mb-2 cursor-pointer">
                            ${isDragging ? "Drop files here" : "Click to Upload or Drag & Drop"}
                        </span>
                        
                        <span class="block text-sm text-gray-500 mb-4">PDF files only (Multiple allowed)</span>
                        <span class="block text-sm font-semibold text-blue-600">${fileSummary}</span>

                        <input type="file" id="fileInput" @change=${handleFileInput} accept="application/pdf" class="hidden" multiple />
                    </label>

                    <!-- Status Container -->
                    ${renderStatus()}

                    <!-- Results Display -->
                    ${isResultVisible ? html`
                        <div>
                            <h2 class="text-2xl font-semibold text-gray-700 mb-4 border-b pb-2">Extracted Data</h2>
                            
                            <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                                <p class="text-sm font-medium text-yellow-800 mb-3 md:mb-0">
                                    <span class="font-bold">Instructions:</span> View detailed data below or toggle summary views.
                                </p>
                                <div class="flex flex-wrap gap-2 w-full md:w-auto">
                                    <button @click=${() => setIsTableVisible(!isTableVisible)} class="flex-shrink-0 w-full md:w-auto px-4 py-2 text-white font-bold rounded-lg shadow transition ${isTableVisible ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-500 hover:bg-gray-600'}">
                                        ${isTableVisible ? 'Hide Details' : 'Show Details'}
                                    </button>
                                    <button @click=${() => setIsConsolidatedVisible(!isConsolidatedVisible)} class="flex-shrink-0 w-full md:w-auto px-4 py-2 text-white font-bold rounded-lg shadow transition ${isConsolidatedVisible ? 'bg-purple-500 hover:bg-purple-600' : 'bg-gray-500 hover:bg-gray-600'}">
                                        ${isConsolidatedVisible ? 'Hide Metadata Summary' : 'Show Metadata Summary'}
                                    </button>
                                    <button @click=${() => copyTable('outputTable')} class="flex-shrink-0 w-full md:w-auto px-4 py-2 bg-green-500 text-white font-bold rounded-lg shadow hover:bg-green-600 transition">
                                        Copy Details
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Consolidated Summary -->
                            ${renderConsolidatedSummary()}

                            <!-- Detailed Table -->
                            ${renderDetailedTable()}

                            <!-- Raw Text Display -->
                            <div class="mt-8">
                                <div class="flex justify-between items-center mb-2">
                                    <h3 class="text-xl font-medium text-gray-700">Raw Extracted Text (For Debugging)</h3>
                                    <button @click=${() => setIsRawTextVisible(!isRawTextVisible)} class="px-3 py-1 text-sm text-white font-bold rounded shadow transition ${isRawTextVisible ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-500 hover:bg-gray-600'}">
                                        ${isRawTextVisible ? 'Hide Raw Text' : 'Show Raw Text'}
                                    </button>
                                </div>
                                
                                ${isRawTextVisible ? html`
                                    <pre class="bg-gray-100 p-4 rounded-lg text-xs overflow-auto max-h-64 border">${rawText}</pre>
                                ` : html`
                                    <div class="p-4 bg-gray-50 border rounded text-xs text-gray-500 italic">Raw text hidden.</div>
                                `}
                            </div>
                        </div>
                    ` : html``}
                </div>
                
                <!-- Modals -->
                ${renderPasswordModal()}
                ${renderTemplatesModal()}
                ${renderParserListModal()}
            `;
        }

        // Register the Web Component
        customElements.define('app-root', component(App, {useShadowDOM: false}));
    </script>
    <app-root></app-root>
</body>
</html>
