<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tax Data Extractor (GST, Income Tax & Bank)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load PDF.js library -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"
    ></script>
    <script>
      // Set the workerSrc for PDF.js
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js";
    </script>
    <style>
      /* Custom styles for better copy/paste experience on the output table */
      .data-table {
        table-layout: fixed;
        width: 100%;
        border-collapse: collapse;
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }
      .data-table td, .data-table th {
        border: 1px solid #e5e7eb;
        padding: 8px;
        text-align: left;
        white-space: nowrap;
      }
      .data-table tr:nth-child(even) {
        background-color: #f9fafb;
      }
      /* Style for the header row specifically */
      .header-row td {
        background-color: #f3f4f6;
        font-weight: bold;
        color: #374151;
      }
      /* Style for file separator rows */
      .file-row td {
        background-color: #bfdbfe; /* Blue-200 */
        font-weight: bold;
        color: #1e3a8a;
        border-top: 2px solid #3b82f6;
      }
      .container {
        max-width: 1024px;
      }
      /* Drag and drop active state */
      .drag-active {
        border-color: #3b82f6 !important; /* blue-500 */
        background-color: #eff6ff !important; /* blue-50 */
        transform: scale(1.01);
        transition: all 0.2s ease;
      }
      /* Modal Backdrop */
      .modal-backdrop {
        background-color: rgba(0, 0, 0, 0.5);
      }
    </style>
  </head>
  <body class="bg-gray-50 p-4 md:p-8">
    <div id="app"></div>

    <script type="module">
      import { html, reactive } from "https://esm.sh/@arrow-js/core";

      // --- Reactive State ---
      const store = reactive({
        fileSummary: "",
        status: { message: "", type: "" }, // type: 'error', 'success', 'info', ''
        allRows: [],
        rawText: "",
        isResultVisible: false,
        isDragging: false,
        isTableVisible: true,
        isRawTextVisible: false,

        // Password Modal State
        passwordModal: {
          isOpen: false,
          fileName: "",
          passwordInput: "",
          useForSubsequent: false,
          resolve: null, // Function to resolve the promise waiting for password
        },
        savedPassword: null, // To store password if "use for subsequent" is checked
      });

      // --- Logic & Helpers ---

      function setStatus(message, type = "info") {
        store.status = { message, type };
      }

      function clearStatus() {
        store.status = { message, type };
      }

      // --- Drag and Drop Handlers ---

      function handleDragOver(e) {
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
        store.isDragging = true;
      }

      function handleDragLeave(e) {
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
        store.isDragging = false;
      }

      function handleDrop(e) {
        if (!e) return;
        e.preventDefault();
        e.stopPropagation();
        store.isDragging = false;

        const dt = e.dataTransfer;
        const files = dt ? dt.files : null;

        if (files && files.length > 0) {
          processFiles(files);
        }
      }

      function handleFileInput(e) {
        const files = e.target.files;
        processFiles(files);
      }

      // --- PDF Processing ---

      // Function to extract text from ALL pages of the PDF, accepting an optional password
      async function extractAllPdfText(file, password = "") {
        const fileReader = new FileReader();
        return new Promise((resolve, reject) => {
          fileReader.onload = async function () {
            const typedarray = new Uint8Array(this.result);
            try {
              // Pass password to getDocument
              const pdf = await pdfjsLib.getDocument({
                data: typedarray,
                password: password,
              }).promise;

              let fullText = "";

              // Iterate through all pages
              for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                fullText += textContent.items.map((item) =>
                  item.str
                ).join(" ") + " ";
              }

              resolve(fullText);
            } catch (error) {
              // Pass specific error object so we can check name/code
              reject(error);
            }
          };
          fileReader.onerror = () =>
            reject(new Error("Error reading file."));
          fileReader.readAsArrayBuffer(file);
        });
      }

      // Wrapper to handle Password Logic
      async function extractTextWithPasswordHandling(file) {
        // 1. Try with no password (or currently saved password if relevant, though usually start blank or specific)
        // Strategy: Always try empty first unless we specifically know.
        // Actually, if we have a saved password, we might want to try that if empty fails.

        try {
          return await extractAllPdfText(file, "");
        } catch (e) {
          if (e.name === "PasswordException") {
            // It is encrypted.

            // 2. Try Saved Password if exists
            if (store.savedPassword) {
              console.log(`Trying saved password for ${file.name}...`);
              try {
                return await extractAllPdfText(
                  file,
                  store.savedPassword,
                );
              } catch (e2) {
                if (e2.name !== "PasswordException") throw e2;
                // Saved password failed, proceed to ask user
              }
            }

            // 3. Prompt User
            while (true) {
              const userResponse = await promptForPassword(file.name);

              if (userResponse.skip) {
                throw new Error("Skipped by user");
              }

              try {
                const text = await extractAllPdfText(
                  file,
                  userResponse.password,
                );

                // If successful and checkbox checked, save it
                if (userResponse.useForSubsequent) {
                  store.savedPassword = userResponse.password;
                }
                return text;
              } catch (e3) {
                if (e3.name !== "PasswordException") throw e3;
                // Password was wrong, loop will continue and prompt again
                alert("Incorrect password. Please try again.");
              }
            }
          }
          throw e; // Rethrow other errors
        }
      }

      function promptForPassword(fileName) {
        return new Promise((resolve) => {
          // Open Modal
          store.passwordModal.fileName = fileName;
          store.passwordModal.passwordInput = ""; // Reset input
          store.passwordModal.useForSubsequent = false;
          store.passwordModal.resolve = resolve;
          store.passwordModal.isOpen = true;
        });
      }

      function handlePasswordSubmit() {
        if (store.passwordModal.resolve) {
          store.passwordModal.resolve({
            password: store.passwordModal.passwordInput,
            useForSubsequent: store.passwordModal.useForSubsequent,
            skip: false,
          });
          store.passwordModal.isOpen = false;
          store.passwordModal.resolve = null;
        }
      }

      function handlePasswordSkip() {
        if (store.passwordModal.resolve) {
          store.passwordModal.resolve({ skip: true });
          store.passwordModal.isOpen = false;
          store.passwordModal.resolve = null;
        }
      }

      async function processFiles(fileList) {
        if (!fileList || fileList.length === 0) {
          store.fileSummary = "";
          store.isResultVisible = false;
          clearStatus();
          return;
        }

        const count = fileList.length;
        store.fileSummary = count === 1
          ? `File: ${fileList[0].name}`
          : `${count} files selected`;

        // Reset Output State
        store.isResultVisible = false;
        store.rawText = "";
        store.allRows = [];
        store.isTableVisible = true;
        store.isRawTextVisible = false;
        store.savedPassword = null; // Reset saved password on new batch? Or keep it? Let's reset for safety.

        let successCount = 0;

        try {
          // Iterate through all files
          for (let i = 0; i < count; i++) {
            const file = fileList[i];
            if (file.type !== "application/pdf") {
              console.log(`Skipping file: ${file.name} (Not a PDF)`); // DEBUG
              continue;
            }

            setStatus(
              `Processing ${i + 1} of ${count}: ${file.name}...`,
              "info",
            );
            console.log(`Starting processing for: ${file.name}`); // DEBUG

            let rawText;
            try {
              rawText = await extractTextWithPasswordHandling(file);
            } catch (extractionError) {
              if (extractionError.message === "Skipped by user") {
                console.log(`Skipped file: ${file.name}`);
                store.rawText +=
                  `\n--- SOURCE: ${file.name} (SKIPPED) ---\n[User skipped password entry]\n`;
                continue;
              }
              console.error(
                `Failed to extract text from ${file.name}:`,
                extractionError,
              );
              store.rawText +=
                `\n--- SOURCE: ${file.name} (ERROR) ---\n[Extraction Failed: ${extractionError.message}]\n`;
              continue;
            }

            // 1. GLOBAL PRE-PROCESSING
            rawText = rawText.replace(/   /g, " ");
            console.log(
              `Raw text extracted (first 200 chars): ${
                rawText.substring(0, 200)
              }...`,
            ); // DEBUG

            // Detect Document Type and Parse
            let parsedData = { allRows: [] };
            let docType = "Unknown";

            // Clean text for detection
            const cleanCheckText = rawText.replace(/\s+/g, " ");

            if (
              cleanCheckText.includes(
                "GOODS AND SERVICES TAX PAYMENT RECEIPT",
              )
            ) {
              docType = "GST Challan";
              parsedData = parseChallanText(rawText);
            } else if (
              cleanCheckText.includes("Form GSTR-3B") ||
              cleanCheckText.includes("See rule 61(5)")
            ) {
              docType = "GSTR-3B";
              parsedData = parseGSTR3BText(rawText);
            } else if (
              cleanCheckText.includes("INCOME TAX DEPARTMENT") &&
              cleanCheckText.includes("Challan Receipt")
            ) {
              docType = "Income Tax";
              parsedData = parseIncomeTaxChallanText(rawText);
            } else if (cleanCheckText.includes("RBL BANK LTD")) {
              docType = "RBL Bank Statement";
              parsedData = parseRBLBankStatementText(rawText);
            } else if (
              cleanCheckText.includes("Canara Bank does not")
            ) {
              docType = "Canara Bank Statement";
              parsedData = parseCanaraBankStatementText(rawText);
            } else if (
              cleanCheckText.includes("Union Bank of India") &&
              cleanCheckText.includes("Statement of Account")
            ) {
              docType = "Union Bank Statement";
              parsedData = parseUnionBankStatementText(rawText);
            } else if (
              cleanCheckText.includes("IDBI Bank or other authorities")
            ) {
              docType = "IDBI Bank Statement";
              parsedData = parseIDBIBankStatementText(rawText);
            } else {
              // Fallback or skip
              store.rawText +=
                `\n--- SOURCE: ${file.name} (Unknown Type) ---\n${rawText}\n`;
              console.log(`Document type unknown for: ${file.name}`); // DEBUG
              continue;
            }

            console.log(`Detected document type: ${docType}`); // DEBUG
            console.log(
              `Parsed ${parsedData.allRows.length} data rows.`,
            ); // DEBUG

            store.rawText +=
              `\n--- SOURCE: ${file.name} (${docType}) ---\n${rawText}\n`;

            // --- Append to Main Table ---
            const fileLabelRow = [
              `Source: ${file.name} (${docType})`,
              "",
              "",
              "",
              "",
              "",
              "",
            ];

            if (store.allRows.length > 0) {
              store.allRows.push(["", "", "", "", "", "", ""]);
            }

            store.allRows.push(fileLabelRow);
            store.allRows.push(...parsedData.allRows);

            successCount++;
          }

          store.isResultVisible = true;

          if (store.allRows.length === 0) {
            setStatus(
              "Processed files but found no recognized data (or skipped).",
              "info",
            );
            console.log(
              "No recognized data found in any processed files.",
            ); // DEBUG
          } else {
            setStatus(
              `Successfully processed ${successCount} files!`,
              "success",
            );
            console.log(
              `Finished processing. Total success count: ${successCount}`,
            ); // DEBUG
          }
        } catch (error) {
          console.error(error);
          setStatus(`Error: ${error.message}`, "error");
          store.isResultVisible = true;
        }
      }

      // --- Parsers (Same as before) ---
      function parseChallanText(rawText) {
        const metadataSpecs = [
          { name: "Name", regex: /Name:\s+(.*)\s+Address/ },
          { name: "GSTIN", regex: /GSTIN:\s+(\w+)/ },
          { name: "Date", regex: /Date :\s+(\d\d\/\d\d\/\d{4})/ },
          { name: "State", regex: /(\d+)\s+([^\d]+?)\s+SGST/ },
        ];
        const getMetadataValue = (spec) => {
          const m = rawText.match(spec.regex);
          if (!m) return "";
          if (spec.name === "State") return `${m[1]} ${m[2]}`;
          return m[1];
        };
        const metadataRows = metadataSpecs.map((spec) => {
          return [
            spec.name,
            getMetadataValue(spec),
            "",
            "",
            "",
            "",
            "",
          ];
        });
        const tableRegex =
          /(?<name>\w+)\(.*?\)\s+(?<tax>-|\d+)\s+(?<interest>-|\d+)\s+(?<penalty>-|\d+)\s+(?<fees>-|\d+)\s+(?<others>-|\d+)\s+(?<total>-|\d+)\s+/g;
        const matches = [...rawText.matchAll(tableRegex)];
        const headers = [
          "Head",
          "Tax",
          "Interest",
          "Penalty",
          "Fees",
          "Others",
          "Total",
        ];
        const dataHeaderRow = headers;
        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.name,
            g.tax,
            g.interest,
            g.penalty,
            g.fees,
            g.others,
            g.total,
          ];
        });
        const totalMatch = rawText.match(/Total Amount\s+([\d,]+)/);
        if (
          totalMatch && !matches.find((m) => m.groups.name === "Total")
        ) {
          dataRows.push([
            "Grand Total",
            "-",
            "-",
            "-",
            "-",
            "-",
            totalMatch[1].replace(/,/g, ""),
          ]);
        }
        return {
          allRows: [...metadataRows, dataHeaderRow, ...dataRows],
        };
      }

      function parseGSTR3BText(rawText) {
        const metadataSpecs = [
          {
            name: "GSTIN",
            regex: /GSTIN\s+of\s+the\s+supplier\s+(\w+)/,
          },
          {
            name: "Name",
            regex:
              /Legal\s+name\s+of\s+the\s+registered\s+person\s+(.*)\s+2\(b\)/,
          },
          {
            name: "Year and Period",
            regex: /Year\s+(.*)\s+Period\s+(\w+)/,
          },
        ];
        const getMetadataValue = (spec) => {
          const m = rawText.match(spec.regex);
          if (!m) return "";
          if (spec.name === "Year and Period") {
            return `Year: ${m[1]} Period: ${m[2]}`;
          }
          return m[1];
        };
        const metadataRows = metadataSpecs.map((spec) => {
          return [
            spec.name,
            getMetadataValue(spec),
            "",
            "",
            "",
            "",
            "",
          ];
        });
        const tableRegex =
          /\([a-e]\s?\)\s+(.*?)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+/g;
        const matches = [...rawText.matchAll(tableRegex)];
        const headers = [
          "Description",
          "Taxable Value",
          "IGST",
          "CGST",
          "SGST/UTGST",
          "Cess",
          "",
        ];
        const dataRows = matches.map((m) => {
          return [m[1].trim(), m[2], m[3], m[4], m[5], m[6], ""];
        });
        return { allRows: [...metadataRows, headers, ...dataRows] };
      }

      function parseIncomeTaxChallanText(rawText) {
        const regex =
          /Nature of Payment : (?<sectionNo>\w+)\s+Amount \(in\s+Rs\.\) : ₹ (?<amt>\d[\d,.]*).*(?<depositDate>\d\d\-\s?\w{3}-\d{4})/g;
        const matches = [...rawText.matchAll(regex)];
        const headers = [
          "Section No",
          "Amount (Rs.)",
          "Deposit Date",
          "",
          "",
          "",
          "",
        ];
        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.sectionNo,
            g.amt,
            g.depositDate.replace(/\s/g, ""),
            "",
            "",
            "",
            "",
          ];
        });
        return { allRows: [headers, ...dataRows] };
      }

      function parseUnionBankStatementText(rawText) {
        const nameMatch = rawText.match(
          /Statement of Account\s+(?<name>.*?)\s+.* Account No/i,
        );
        const accountMatch = rawText.match(
          /Account No\s+(?<accountNo>\d+)/i,
        );
        const metadataRows = [[
          "Account Holder Name",
          nameMatch?.groups?.name?.trim() || "N/A",
          "",
          "",
          "",
          "",
          "",
        ], [
          "Account Number",
          accountMatch?.groups?.accountNo || "N/A",
          "",
          "",
          "",
          "",
          "",
        ]];
        const tableRegex =
          /(?<date>\d\d-\d\d-\d{4})\s+\d\d:\d\d:\d\d\s+(?<particulars>.*?)\s+(?<amt>[\d,]+\.\d\s?\d)\s+(?<bal>-?\s?[\d,]+\.\d\s?\d)/g;
        const matches = [...rawText.matchAll(tableRegex)];
        const headers = [
          "Date",
          "Particulars/Description",
          "Amount",
          "Balance",
          "",
          "",
          "",
        ];
        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.date,
            g.particulars.trim(),
            g.amt.replace(/\s/g, ""),
            g.bal.replace(/\s/g, ""),
            "",
            "",
            "",
          ];
        });
        return { allRows: [...metadataRows, headers, ...dataRows] };
      }

      function parseCanaraBankStatementText(rawText) {
        const metadataRegex =
          /Account Number (?<accountNo>\d+).* Opening Balance Rs\. (?<opBal>-?[\d,]+\.\d\d)\s+Closing Balance Rs\. (?<closeBal>-?[\d,]+\.\d\d)/s;
        const metadataMatch = rawText.match(metadataRegex);
        const metadataRows = [[
          "Account Number",
          metadataMatch?.groups?.accountNo || "N/A",
          "",
          "",
          "",
          "",
          "",
        ], [
          "Opening Balance",
          metadataMatch?.groups?.opBal || "N/A",
          "",
          "",
          "",
          "",
          "",
        ], [
          "Closing Balance",
          metadataMatch?.groups?.closeBal || "N/A",
          "",
          "",
          "",
          "",
          "",
        ]];
        const tableRegex =
          /\s\s(?<date>\d\d-\d\d-\d{4})\s+\d\d:\d\d:\d\d\s+(?<particulars>.*?)\s+(?<amt>[\d+,]+\.\d\d)\s+(?<bal>-?[\d+,]+\.\d\d)/g;
        const matches = [...rawText.matchAll(tableRegex)];
        const headers = [
          "Date",
          "Particulars/Description",
          "Amount",
          "Balance",
          "",
          "",
          "",
        ];
        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.date,
            g.particulars.trim(),
            g.amt.replace(/,/g, ""),
            g.bal.replace(/,/g, ""),
            "",
            "",
            "",
          ];
        });
        return { allRows: [...metadataRows, headers, ...dataRows] };
      }

      function parseRBLBankStatementText(rawText) {
        const metadataRegex =
          /Account Name: (?<AccName>.*?) Home Branch: .* in Account Number:\s+(?<AccountNo>\d+)\s+.* Opening Balance: ₹ (?<Opbal>[\d,]+\.\d{2})\s+Count Of Debit: \d+\s+Closing Balance: ₹ (?<ClBal>[\d,]+\.\d{2})/s;
        const metadataMatch = rawText.match(metadataRegex);
        const metadataRows = [[
          "Account Name",
          metadataMatch?.groups?.AccName?.trim() || "N/A",
          "",
          "",
          "",
          "",
          "",
        ], [
          "Account Number",
          metadataMatch?.groups?.AccountNo || "N/A",
          "",
          "",
          "",
          "",
          "",
        ], [
          "Opening Balance",
          metadataMatch?.groups?.Opbal || "N/A",
          "",
          "",
          "",
          "",
          "",
        ], [
          "Closing Balance",
          metadataMatch?.groups?.ClBal || "N/A",
          "",
          "",
          "",
          "",
          "",
        ]];
        const tableHeaderStart = rawText.indexOf("Value Date");
        let transactionText = rawText;
        if (tableHeaderStart !== -1) {
          const dateHeaderIndex = rawText.indexOf("Date Value Date");
          if (dateHeaderIndex !== -1) {
            transactionText = rawText.substring(dateHeaderIndex);
          } else transactionText = rawText.substring(tableHeaderStart);
        }
        const tableRegex = new RegExp(
          /(?<date>\d\d\/\d\d\/\d{4})\s+\d\d\/\d\d\/\d{4}\s+(?<particular>.*?)\s+(?<amt>[\d,]+\.\s?\d\s?\d)\s+(?<bal>[\d,]+\s?\.\s?\d\s?\d)/g,
        );
        const matches = [...transactionText.matchAll(tableRegex)];
        const headers = [
          "Date",
          "Particulars/Description",
          "Amount",
          "Balance",
          "",
          "",
          "",
        ];
        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.date,
            g.particular.trim(),
            g.amt.replace(/,/g, "").replace(/\s/g, ""),
            g.bal.replace(/\s/g, ""),
            "",
            "",
            "",
          ];
        });
        return { allRows: [...metadataRows, headers, ...dataRows] };
      }

      function parseIDBIBankStatementText(rawText) {
        const metadataRegex =
          /^(?<Name>.*?) Address .* A\/C NO: (?<AccNo>\d+)/s;
        const metadataMatch = rawText.match(metadataRegex);
        const metadataRows = [[
          "Account Name",
          metadataMatch?.groups?.Name?.trim() || "N/A",
          "",
          "",
          "",
          "",
          "",
        ], [
          "Account Number",
          metadataMatch?.groups?.AccNo || "N/A",
          "",
          "",
          "",
          "",
          "",
        ]];
        const tableRegex = new RegExp(
          /(?<date>\d\d\/\d\d\/\d{4})\s+(?<particular>.*?)\s+(?<type>Dr\.|Cr\.)\s+\w{3}\s+(?<Amt>[\d,]+\.\d{2})\s+\d\d\/\d\d\/\d{4}\s+\d\d:\d\d:\d\d\s+(?<serialNo>\d+)\s+(?<Bal>-?[\d,]+\.\d{2})/g,
        );
        const matches = [...rawText.matchAll(tableRegex)];
        const headers = [
          "Date",
          "Particulars/Description",
          "Type",
          "Amount",
          "Serial No",
          "Balance",
          "",
        ];
        const dataRows = matches.map((m) => {
          const g = m.groups;
          const amount = g.type === "Dr." ? `-${g.Amt}` : g.Amt;
          return [
            g.date,
            g.particular.trim(),
            g.type,
            amount.replace(/,/g, ""),
            g.serialNo,
            g.Bal.replace(/,/g, ""),
            "",
          ];
        });
        return { allRows: [...metadataRows, headers, ...dataRows] };
      }

      function copyTable() {
        if (store.allRows.length === 0) return;
        const tsvText = store.allRows.map((row) => row.join("\t")).join(
          "\n",
        );
        const tempTextArea = document.createElement("textarea");
        tempTextArea.style.position = "fixed";
        tempTextArea.style.opacity = "0";
        tempTextArea.value = tsvText;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        try {
          document.execCommand("copy");
          setStatus("All table data copied to clipboard!", "success");
        } catch (err) {
          setStatus("Manual copy required.", "error");
        } finally {
          document.body.removeChild(tempTextArea);
          setTimeout(clearStatus, 3000);
        }
      }

      // --- Templates ---

      const tableToggleClass = () => {
        return `flex-shrink-0 w-full md:w-auto px-4 py-2 text-white font-bold rounded-lg shadow transition duration-150 ${
          store.isTableVisible
            ? "bg-blue-500 hover:bg-blue-600"
            : "bg-gray-500 hover:bg-gray-600"
        }`;
      };

      const rawTextToggleClass = () => {
        return `px-3 py-1 text-sm text-white font-bold rounded shadow transition duration-150 ${
          store.isRawTextVisible
            ? "bg-blue-500 hover:bg-blue-600"
            : "bg-gray-500 hover:bg-gray-600"
        }`;
      };

      const statusTemplate = html`
        ${() => {
          if (!store.status.message) return "";
          const baseClasses = "p-4 rounded-lg text-sm mb-6";
          const typeClasses = store.status.type === "error"
            ? "bg-red-100 text-red-800"
            : store.status.type === "success"
            ? "bg-green-100 text-green-800"
            : "bg-blue-100 text-blue-800";
          return html`
            <div class="${baseClasses} ${typeClasses}" role="alert">${store
              .status.message}</div>
          `;
        }}
      `;

      const modalTemplate = html`
        ${() => {
          if (!store.passwordModal.isOpen) return "";
          return html`
            <div
              class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop"
            >
              <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
                <h3 class="text-xl font-bold text-gray-800 mb-4">
                  Password Required
                </h3>
                <p class="text-sm text-gray-600 mb-2">
                  The file <span class="font-bold text-blue-600">${store
                    .passwordModal.fileName}</span>
                  is encrypted.
                </p>

                <div class="mb-4">
                  <label class="block text-sm font-medium text-gray-700 mb-1"
                  >Enter Password</label>
                  <input
                    type="text"
                    class="w-full border border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    placeholder="Password"
                    value="${() => store.passwordModal.passwordInput}"
                    @input="${(e) =>
                      store.passwordModal.passwordInput =
                        e.target.value}"
                    @keydown="${(e) =>
                      e.key === "Enter" && handlePasswordSubmit()}"
                  >
                </div>

                <div class="flex items-center mb-6">
                  <input
                    type="checkbox"
                    id="useForSubsequent"
                    class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                    checked="${() =>
                      store.passwordModal.useForSubsequent}"
                    @change="${(e) =>
                      store.passwordModal.useForSubsequent =
                        e.target.checked}"
                  >
                  <label
                    for="useForSubsequent"
                    class="ml-2 block text-sm text-gray-700"
                  >
                    Use this password for subsequent files
                  </label>
                </div>

                <div class="flex justify-end space-x-3">
                  <button
                    @click="${handlePasswordSkip}"
                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium text-sm"
                  >
                    Skip File
                  </button>
                  <button
                    @click="${handlePasswordSubmit}"
                    class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium text-sm"
                  >
                    Decrypt & Extract
                  </button>
                </div>
              </div>
            </div>
          `;
        }}
      `;

      const tableTemplate = html`
        <div class="overflow-x-auto border rounded-lg">
          <table id="outputTable">
            <tbody>
              ${() =>
                store.allRows.map((row, index) => {
                  const isSourceHeader = row[0] &&
                    row[0].startsWith("Source:");
                  const firstCell = row[0] || "";
                  const isHeader =
                    (firstCell === "Head" && row[1] === "Tax") ||
                    (firstCell === "Description" &&
                      row[1] === "Taxable Value") ||
                    (firstCell === "Section No" &&
                      row[1] === "Amount (Rs.)") ||
                    (firstCell === "Date" &&
                      row[1] === "Particulars/Description");

                  let rowClass = "";
                  if (isSourceHeader) rowClass = "file-row";
                  else if (isHeader) rowClass = "header-row";

                  return html`
                    <tr class="${rowClass}">
                      ${row.map((cell) =>
                        html`
                          <td>${cell}</td>
                        `
                      )}
                    </tr>
                  `;
                })}
            </tbody>
          </table>
        </div>
      `;

      const resultsTemplate = html`
        ${() => {
          if (!store.isResultVisible) return "";
          return html`
            <div>
              <h2 class="text-2xl font-semibold text-gray-700 mb-4 border-b pb-2">
                Extracted Data
              </h2>

              <div
                class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg"
              >
                <p class="text-sm font-medium text-yellow-800 mb-3 md:mb-0">
                  <span class="font-bold">Instructions:</span> Copy the table below
                  to paste into Excel.
                </p>
                <div class="flex space-x-4 w-full md:w-auto">
                  <!-- Table Visibility Toggle -->
                  <button
                    @click="${() =>
                      store.isTableVisible = !store.isTableVisible}"
                    class="${tableToggleClass}"
                  >
                    ${() =>
                      store.isTableVisible
                        ? "Hide Table"
                        : "Show Table"}
                  </button>
                  <!-- Copy Button -->
                  <button
                    @click="${copyTable}"
                    class="flex-shrink-0 w-full md:w-auto px-4 py-2 bg-green-500 text-white font-bold rounded-lg shadow hover:bg-green-600 transition duration-150"
                  >
                    Copy All to Clipboard
                  </button>
                </div>
              </div>

              <!-- Conditional Table Rendering -->
              ${() =>
                store.isTableVisible ? tableTemplate : html`
                  <div class="p-8 text-center text-gray-500 border rounded-lg bg-white">
                    The extracted data table is currently hidden. Click the "Show Table"
                    button above to view the data.
                  </div>
                `}

              <div class="mt-8">
                <div class="flex justify-between items-center mb-2">
                  <h3 class="text-xl font-medium text-gray-700">
                    Raw Extracted Text (For Debugging)
                  </h3>
                  <!-- Raw Text Toggle -->
                  <button
                    @click="${() =>
                      store.isRawTextVisible = !store.isRawTextVisible}"
                    class="${rawTextToggleClass}"
                  >
                    ${() =>
                      store.isRawTextVisible
                        ? "Hide Raw Text"
                        : "Show Raw Text"}
                  </button>
                </div>

                ${() =>
                  store.isRawTextVisible
                    ? html`
                      <pre
                        class="bg-gray-100 p-4 rounded-lg text-xs overflow-auto max-h-64 border"
                      >${store.rawText}</pre>
                    `
                    : html`
                      <div class="p-4 bg-gray-50 border rounded text-xs text-gray-500 italic">
                        Raw text hidden.
                      </div>
                    `}
              </div>
            </div>
          `;
        }}
      `;

      // Helper to generate class string safely
      const dropZoneClass = () => {
        const base =
          "mb-8 p-10 border-2 border-dashed rounded-lg bg-blue-50 transition-all duration-200 flex flex-col items-center justify-center text-center cursor-pointer block";
        const active = store.isDragging
          ? "drag-active"
          : "border-blue-300";
        return `${base} ${active}`;
      };

      const mainTemplate = html`
        <div
          class="container mx-auto bg-white shadow-xl rounded-xl p-6 md:p-10 relative"
        >
          <h1 class="text-3xl font-extrabold text-blue-800 mb-2">
            Tax & Bank Data Extractor
          </h1>
          <p class="text-gray-600 mb-6">
            Supports <strong>GST Receipts</strong>, <strong>GSTR-3B</strong>,
            <strong>Income Tax Challans</strong>, <strong>Union Bank</strong>,
            <strong>Canara Bank</strong>, <strong>RBL Bank</strong>, and <strong
            >IDBI Bank Statements</strong>.
            <br>Drag and drop multiple PDF files to process them in batch.
          </p>

          <!-- File Input / Drop Zone -->
          <label
            for="gstFileInput"
            class="${dropZoneClass}"
            @dragover="${(e) => handleDragOver(e)}"
            @dragleave="${(e) => handleDragLeave(e)}"
            @drop="${(e) => handleDrop(e)}"
          >
            <svg
              class="w-12 h-12 text-blue-500 mb-3"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
              >
              </path>
            </svg>

            <span
              class="block text-lg font-medium text-blue-700 mb-2 cursor-pointer"
            >
              ${() =>
                store.isDragging
                  ? "Drop files here"
                  : "Click to Upload or Drag & Drop"}
            </span>

            <span class="block text-sm text-gray-500 mb-4"
            >PDF files only (Multiple allowed)</span>
            <span class="block text-sm font-semibold text-blue-600"
            >${() => store.fileSummary}</span>

            <input
              type="file"
              id="gstFileInput"
              @change="${handleFileInput}"
              accept="application/pdf"
              class="hidden"
              multiple
            >
          </label>

          ${statusTemplate} ${resultsTemplate} ${modalTemplate}
        </div>
      `;

      // Mount application
      mainTemplate(document.getElementById("app"));
    </script>
  </body>
</html>
