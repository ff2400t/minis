<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tax Data Extractor (GST, Income Tax & Bank)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load PDF.js library -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"
    ></script>
    <script>
      // Set the workerSrc for PDF.js
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js";
    </script>
    <style>
      /* Custom styles for better copy/paste experience on the output table */
      #outputTable {
        table-layout: fixed;
        width: 100%;
        border-collapse: collapse;
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }
      #outputTable td {
        border: 1px solid #e5e7eb;
        padding: 8px;
        text-align: left;
        white-space: nowrap;
      }
      #outputTable tr:nth-child(even) {
        background-color: #f9fafb;
      }
      /* Style for the header row specifically */
      .header-row td {
        background-color: #f3f4f6;
        font-weight: bold;
        color: #374151;
      }
      /* Style for file separator rows */
      .file-row td {
        background-color: #bfdbfe; /* Blue-200 */
        font-weight: bold;
        color: #1e3a8a;
        border-top: 2px solid #3b82f6;
      }
      .container {
        max-width: 1024px;
      }
      /* Drag and drop active state */
      .drag-active {
        border-color: #3b82f6 !important; /* blue-500 */
        background-color: #eff6ff !important; /* blue-50 */
        transform: scale(1.01);
        transition: all 0.2s ease;
      }
    </style>
  </head>
  <body class="bg-gray-50 p-4 md:p-8">
    <div id="app"></div>

    <script type="module">
      import { html, reactive } from "https://esm.sh/@arrow-js/core";

      // --- Reactive State ---
      const store = reactive({
        fileSummary: "",
        status: { message: "", type: "" }, // type: 'error', 'success', 'info', ''
        allRows: [], // Contains rows from ALL processed files
        rawText: "", // Combined raw text for debugging
        isResultVisible: false,
        isDragging: false,
        isTableVisible: true, // New state for toggle
      });

      // --- Logic & Helpers ---

      function setStatus(message, type = "info") {
        store.status = { message, type };
      }

      function clearStatus() {
        store.status = { message: "", type: "" };
      }

      // --- Drag and Drop Handlers ---

      function handleDragOver(e) {
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
        store.isDragging = true;
      }

      function handleDragLeave(e) {
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
        store.isDragging = false;
      }

      function handleDrop(e) {
        if (!e) return;
        e.preventDefault();
        e.stopPropagation();
        store.isDragging = false;

        const dt = e.dataTransfer;
        const files = dt ? dt.files : null;

        if (files && files.length > 0) {
          processFiles(files);
        }
      }

      function handleFileInput(e) {
        const files = e.target.files;
        processFiles(files);
      }

      // --- PDF Processing ---

      // Function to extract text from ALL pages of the PDF
      async function extractAllPdfText(file) {
        const fileReader = new FileReader();
        return new Promise((resolve, reject) => {
          fileReader.onload = async function () {
            const typedarray = new Uint8Array(this.result);
            try {
              const pdf = await pdfjsLib.getDocument({
                data: typedarray,
              }).promise;
              let fullText = "";

              // Iterate through all pages
              for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                // Join text content from this page, add a space to separate words across pages/lines
                fullText += textContent.items.map((item) =>
                  item.str
                ).join(" ") + " ";
              }

              resolve(fullText);
            } catch (error) {
              reject(new Error(`Could not parse PDF ${file.name}.`));
            }
          };
          fileReader.onerror = () =>
            reject(new Error("Error reading file."));
          fileReader.readAsArrayBuffer(file);
        });
      }

      async function processFiles(fileList) {
        if (!fileList || fileList.length === 0) {
          store.fileSummary = "";
          store.isResultVisible = false;
          clearStatus();
          return;
        }

        const count = fileList.length;
        store.fileSummary = count === 1
          ? `File: ${fileList[0].name}`
          : `${count} files selected`;

        // Reset Output State
        store.isResultVisible = false;
        store.rawText = "";
        store.allRows = [];
        store.isTableVisible = true; // Show table by default when new files are processed

        let successCount = 0;

        try {
          // Iterate through all files
          for (let i = 0; i < count; i++) {
            const file = fileList[i];
            if (file.type !== "application/pdf") {
              console.log(`Skipping file: ${file.name} (Not a PDF)`); // DEBUG: Skipping non-PDFs
              continue;
            }

            setStatus(
              `Processing ${i + 1} of ${count}: ${file.name}...`,
              "info",
            );
            console.log(`Starting processing for: ${file.name}`); // DEBUG: File start

            let rawText = await extractAllPdfText(file);

            // 1. GLOBAL PRE-PROCESSING: Replace triple spaces with single space
            rawText = rawText.replace(/   /g, " ");
            console.log(
              `Raw text extracted (first 200 chars): ${
                rawText.substring(0, 200)
              }...`,
            ); // DEBUG: Raw text check

            // Detect Document Type and Parse
            let parsedData = { allRows: [] };
            let docType = "Unknown";

            // Clean text for detection (remove excessive whitespace for checking keywords)
            const cleanCheckText = rawText.replace(/\s+/g, " ");

            // Check for document types in order of specificity/preference
            if (
              cleanCheckText.includes(
                "GOODS AND SERVICES TAX PAYMENT RECEIPT",
              )
            ) {
              docType = "GST Challan";
              parsedData = parseChallanText(rawText);
            } else if (
              cleanCheckText.includes("Form GSTR-3B") ||
              cleanCheckText.includes("See rule 61(5)")
            ) {
              docType = "GSTR-3B";
              parsedData = parseGSTR3BText(rawText);
            } else if (
              cleanCheckText.includes("INCOME TAX DEPARTMENT") &&
              cleanCheckText.includes("Challan Receipt")
            ) {
              docType = "Income Tax";
              parsedData = parseIncomeTaxChallanText(rawText);
            } else if (
              cleanCheckText.includes("Payment Confirmation Receipt") &&
              cleanCheckText.includes("TRRN No")
            ) {
              docType = "PF Receipts";
              parsedData = parsePFPaymentReceiptsText(rawText);
            } else if (
              cleanCheckText.includes("CHALLAN MTR Form Number-6")
            ) {
              docType = "PT Challan";
              parsedData = parsePTChallanText(rawText);
            } else if (cleanCheckText.includes("RBL BANK LTD")) {
              docType = "RBL Bank Statement";
              parsedData = parseRBLBankStatementText(rawText);
            } else if (
              cleanCheckText.includes("Canara Bank does not")
            ) {
              // Canara Bank detection
              docType = "Canara Bank Statement";
              parsedData = parseCanaraBankStatementText(rawText);
            } else if (
              cleanCheckText.includes("Union Bank of India") &&
              cleanCheckText.includes("Statement of Account")
            ) {
              docType = "Union Bank Statement";
              parsedData = parseUnionBankStatementText(rawText);
            } else if (
              cleanCheckText.includes("IDBI Bank or other authorities")
            ) {
              docType = "IDBI Bank Statement";
              parsedData = parseIDBIBankStatementText(rawText);
            } else {
              // Fallback or skip
              store.rawText +=
                `\n--- SOURCE: ${file.name} (Unknown Type) ---\n${rawText}\n`;
              console.log(`Document type unknown for: ${file.name}`); // DEBUG: Unknown type
              continue;
            }

            console.log(`Detected document type: ${docType}`); // DEBUG: Detected type
            console.log(
              `Parsed ${parsedData.allRows.length} data rows.`,
            ); // DEBUG: Row count

            store.rawText +=
              `\n--- SOURCE: ${file.name} (${docType}) ---\n${rawText}\n`;

            // --- Append to Main Table ---

            // 1. Add visual separator/filename row
            // We pad to a safe number of columns (7) to ensure grid integrity
            const fileLabelRow = [
              `Source:`,
              file.name,
              docType,
              "",
              "",
              "",
              "",
            ];

            // Add spacer if this isn't the first file
            if (store.allRows.length > 0) {
              store.allRows.push(["", "", "", "", "", "", ""]);
            }

            store.allRows.push(fileLabelRow);
            store.allRows.push(...parsedData.allRows);

            successCount++;
          }

          store.isResultVisible = true;

          if (store.allRows.length === 0) {
            setStatus(
              "Processed files but found no recognized data.",
              "info",
            );
            console.log(
              "No recognized data found in any processed files.",
            ); // DEBUG: No data
          } else {
            setStatus(
              `Successfully processed ${successCount} files!`,
              "success",
            );
            console.log(
              `Finished processing. Total success count: ${successCount}`,
            ); // DEBUG: Success
          }
        } catch (error) {
          console.error(error);
          setStatus(`Error: ${error.message}`, "error");
          store.isResultVisible = true;
        }
      }

      // --- Parser 1: GST Challan ---
      function parseChallanText(rawText) {
        // Metadata
        const metadataSpecs = [
          { name: "Name", regex: /Name:\s+(.*)\s+Address/ },
          { name: "GSTIN", regex: /GSTIN:\s+(\w+)/ },
          { name: "Date", regex: /Date :\s+(\d\d\/\d\d\/\d{4})/ },
          { name: "State", regex: /(\d+)\s+([^\d]+?)\s+SGST/ },
        ];

        const getMetadataValue = (spec) => {
          const m = rawText.match(spec.regex);
          if (!m) return "";
          if (spec.name === "State") {
            return `${m[1]} ${m[2]}`;
          }
          return m[1];
        };

        const metadataRows = metadataSpecs.map((spec) => {
          return [
            spec.name,
            getMetadataValue(spec),
            "",
            "",
            "",
            "",
            "",
          ];
        });

        // Table
        const tableRegex =
          /(?<name>\w+)\(.*?\)\s+(?<tax>-|\d+)\s+(?<interest>-|\d+)\s+(?<penalty>-|\d+)\s+(?<fees>-|\d+)\s+(?<others>-|\d+)\s+(?<total>-|\d+)\s+/g;

        const matches = [...rawText.matchAll(tableRegex)];
        const headers = [
          "Head",
          "Tax",
          "Interest",
          "Penalty",
          "Fees",
          "Others",
          "Total",
        ];
        const dataHeaderRow = headers;

        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.name,
            g.tax,
            g.interest,
            g.penalty,
            g.fees,
            g.others,
            g.total,
          ];
        });

        // Add Grand Total row if found
        const totalMatch = rawText.match(/Total Amount\s+([\d,]+)/);
        if (
          totalMatch && !matches.find((m) => m.groups.name === "Total")
        ) {
          dataRows.push([
            "Grand Total",
            "-",
            "-",
            "-",
            "-",
            "-",
            totalMatch[1].replace(/,/g, ""),
          ]);
        }

        const allRows = [
          ...metadataRows,
          dataHeaderRow,
          ...dataRows,
        ];

        return { allRows };
      }

      // --- Parser 2: GSTR-3B ---
      function parseGSTR3BText(rawText) {
        // Metadata
        const metadataSpecs = [
          {
            name: "GSTIN",
            regex: /GSTIN\s+of\s+the\s+supplier\s+(\w+)/,
          },
          {
            name: "Name",
            regex:
              /Legal\s+name\s+of\s+the\s+registered\s+person\s+(.*)\s+2\(b\)/,
          },
          {
            name: "Year and Period",
            regex: /Year\s+(.*)\s+Period\s+(\w+)/,
          },
        ];

        const getMetadataValue = (spec) => {
          const m = rawText.match(spec.regex);
          if (!m) return "";
          if (spec.name === "Year and Period") {
            return `Year: ${m[1]} Period: ${m[2]}`;
          }
          return m[1];
        };

        const metadataRows = metadataSpecs.map((spec) => {
          return [
            spec.name,
            getMetadataValue(spec),
            "",
            "",
            "",
            "",
            "",
          ];
        });

        // Table Extraction
        const tableRegex =
          /\([a-e]\s?\)\s+(.*?)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+/g;

        const matches = [...rawText.matchAll(tableRegex)];

        // Define Headers for GSTR-3B
        const headers = [
          "Description",
          "Taxable Value",
          "IGST",
          "CGST",
          "SGST/UTGST",
          "Cess",
          "",
        ];

        const dataRows = matches.map((m) => {
          return [
            m[1].trim(), // Description
            m[2], // Taxable
            m[3], // IGST
            m[4], // CGST
            m[5], // SGST
            m[6], // Cess
            "", // Empty 7th column
          ];
        });

        const allRows = [
          ...metadataRows,
          headers,
          ...dataRows,
        ];

        return { allRows };
      }

      // --- Parser 3: Income Tax Challan ---
      function parseIncomeTaxChallanText(rawText) {
        // Regex for Income Tax Challan
        const regex =
          /Nature of Payment : (?<sectionNo>\w+)\s+Amount \(in\s+Rs\.\) : ₹ (?<amt>\d[\d,.]*).*(?<depositDate>\d\d\-\s?\w{3}-\d{4})/g;

        const matches = [...rawText.matchAll(regex)];

        // Column names from regex capture groups: sectionNo, amt, depositDate
        const headers = [
          "Section No",
          "Amount (Rs.)",
          "Deposit Date",
          "",
          "",
          "",
          "",
        ];

        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.sectionNo,
            g.amt,
            g.depositDate.replace(/\s/g, ""), // Remove potential spaces in date
            "",
            "",
            "",
            "", // Pad to 7 columns
          ];
        });

        const allRows = [
          headers,
          ...dataRows,
        ];

        return { allRows };
      }

      // --- Parser 4: PF Payment Receipt  ---
      function parsePFPaymentReceiptsText(rawText) {
        // Regex as requested
        // Using slightly loose whitespace (\s+) in the middle to be robust after the replaceAll
        const regex =
          /ID : (?<Name>.*) Establishment Name.*\s(?<WageMonth>\w+-\d{4}) Wage Month : (?<Amt>\d[\d,.]*).*Payment Date : (?<PaymentDate>\d{2}-\w+-\d{4})/g;

        const matches = [...rawText.matchAll(regex)];

        // Column names from regex capture groups: sectionNo, amt, depositDate
        const headers = [
          "Name",
          "Month",
          "Amount",
          "Payment Date",
          "",
          "",
          "",
        ];

        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.Name,
            g.WageMonth,
            g.Amt,
            g.PaymentDate,
            "",
            "",
            "", // Pad to 7 columns
          ];
        });

        const allRows = [
          headers,
          ...dataRows,
        ];

        return { allRows };
      }

      // --- Parser 5: PF Challan ---
      function parsePTChallanText(rawText) {
        // Regex as requested
        // Using slightly loose whitespace (\s+) in the middle to be robust after the replaceAll
        const regex =
          /Full Name (?<name>.*) Location.*From (?<period>.*) Flat.*TAX (?<amt>\d+\.\d{2}).*RBI Date (?<paymentDate>\d\d\/\d\d\/\d{4})/g;

        const matches = [...rawText.matchAll(regex)];

        // Column names from regex capture groups: sectionNo, amt, depositDate
        const headers = [
          "Name",
          "period",
          "Amount",
          "Date",
          "",
          "",
          "",
        ];

        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.name,
            g.period,
            g.amt,
            g.paymentDate,
            "",
            "",
            "", // Pad to 7 columns
          ];
        });

        const allRows = [
          headers,
          ...dataRows,
        ];

        return { allRows };
      }

      // --- Parser 6: Union Bank Statement ---
      function parseUnionBankStatementText(rawText) {
        // 1. Metadata Extraction
        const nameMatch = rawText.match(
          /Statement of Account\s+(?<name>.*?)\s+.* Account No/i,
        );
        const accountMatch = rawText.match(
          /Account No\s+(?<accountNo>\d+)/i,
        );

        const metadataRows = [
          [
            "Account Holder Name",
            nameMatch?.groups?.name?.trim() || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
          [
            "Account Number",
            accountMatch?.groups?.accountNo || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
        ];

        // 2. Transaction Table Extraction
        // Regex: /(?<date>\d\d-\d\d-\d{4})\s+\d\d:\d\d:\d\d\s+(?<particulars>.*?)\s+(?<amt>[\d,]+\.\d\s?\d)\s+(?<bal>-?\s?[\d,]+\.\d\s?\d)/g
        const tableRegex =
          /(?<date>\d\d-\d\d-\d{4})\s+\d\d:\d\d:\d\d\s+(?<particulars>.*?)\s+(?<amt>[\d,]+\.\d\s?\d)\s+(?<bal>-?\s?[\d,]+\.\d\s?\d)/g;

        const matches = [...rawText.matchAll(tableRegex)];

        // Define Headers for Union Bank Statement
        const headers = [
          "Date",
          "Particulars/Description",
          "Amount",
          "Balance",
          "",
          "",
          "",
        ];

        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.date,
            g.particulars.trim(),
            // Clean the amounts by removing any spaces that might be captured due to the flexible regex
            g.amt.replace(/\s/g, ""),
            g.bal.replace(/\s/g, ""),
            "",
            "",
            "", // Pad to 7 columns
          ];
        });

        const allRows = [
          ...metadataRows,
          headers,
          ...dataRows,
        ];

        return { allRows };
      }

      // --- Parser 7: Canara Bank Statement ---
      function parseCanaraBankStatementText(rawText) {
        // 1. Metadata Extraction
        // Regex: /Account Number (?<accountNo>\d+).* Opening Balance Rs. (?<opBal>-?[\d,]+\.\d\d)  Closing Balance Rs. (?<closeBal>-?[\d,]+\.\d\d)/
        const metadataRegex =
          /Account Number (?<accountNo>\d+).* Opening Balance Rs\. (?<opBal>-?[\d,]+\.\d\d)\s+Closing Balance Rs\. (?<closeBal>-?[\d,]+\.\d\d)/s;
        const metadataMatch = rawText.match(metadataRegex);

        const metadataRows = [
          [
            "Account Number",
            metadataMatch?.groups?.accountNo || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
          [
            "Opening Balance",
            metadataMatch?.groups?.opBal || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
          [
            "Closing Balance",
            metadataMatch?.groups?.closeBal || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
        ];

        // 2. Transaction Table Extraction
        // Regex: \s\s(?<date>\d\d-\d\d-\d{4}) \d\d:\d\d:\d\d (.*?) (?<amt>[\d+,]+\.\d\d) (?<bal>-?[\d+,]+\.\d\d)
        const tableRegex =
          /\s\s(?<date>\d\d-\d\d-\d{4})\s+\d\d:\d\d:\d\d\s+(?<particulars>.*?)\s+(?<amt>[\d+,]+\.\d\d)\s+(?<bal>-?[\d+,]+\.\d\d)/g;

        const matches = [...rawText.matchAll(tableRegex)];

        // Define Headers for Canara Bank Statement
        const headers = [
          "Date",
          "Particulars/Description",
          "Amount",
          "Balance",
          "",
          "",
          "",
        ];

        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.date,
            g.particulars.trim(),
            g.amt.replace(/,/g, ""), // Clean commas from amount
            g.bal.replace(/,/g, ""), // Clean commas from balance
            "",
            "",
            "", // Pad to 7 columns
          ];
        });

        const allRows = [
          ...metadataRows,
          headers,
          ...dataRows,
        ];

        return { allRows };
      }

      // --- Parser 8: RBL Bank Statement ---
      function parseRBLBankStatementText(rawText) {
        // 1. Metadata Extraction (using dotAll flag 's')
        const metadataRegex =
          /Account Name: (?<AccName>.*?) Home Branch: .* in Account Number:\s+(?<AccountNo>\d+)\s+.* Opening Balance: ₹ (?<Opbal>[\d,]+\.\d{2})\s+Count Of Debit: \d+\s+Closing Balance: ₹ (?<ClBal>[\d,]+\.\d{2})/s;
        const metadataMatch = rawText.match(metadataRegex);

        const metadataRows = [
          [
            "Account Name",
            metadataMatch?.groups?.AccName?.trim() || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
          [
            "Account Number",
            metadataMatch?.groups?.AccountNo || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
          [
            "Opening Balance",
            metadataMatch?.groups?.Opbal || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
          [
            "Closing Balance",
            metadataMatch?.groups?.ClBal || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
        ];

        // 2. Preprocessing: Clear text before the transaction table header ("Value Date")
        const tableHeaderStart = rawText.indexOf("Value Date");
        let transactionText = rawText;

        if (tableHeaderStart !== -1) {
          // Find the start of the table block (usually begins with 'Date')
          const dateHeaderIndex = rawText.indexOf("Date Value Date");
          if (dateHeaderIndex !== -1) {
            transactionText = rawText.substring(dateHeaderIndex);
          } else {
            // Fallback to searching from Value Date
            transactionText = rawText.substring(tableHeaderStart);
          }
        }

        // 3. Transaction Table Extraction
        // Updated Regex: /(?<date>\d\d\/\d\d\/\d{4}) \d\d\/\d\d\/\d{4} (?<particular>.*?) (?<amt>[\d,]+\.\s?\d\s?\d) (?<bal>[\d,]+\s?\.\s?\d\s?\d)/g
        const tableRegex = new RegExp(
          /(?<date>\d\d\/\d\d\/\d{4})\s+\d\d\/\d\d\/\d{4}\s+(?<particular>.*?)\s+(?<amt>[\d,]+\.\s?\d\s?\d)\s+(?<bal>[\d,]+\s?\.\s?\d\s?\d)/g,
        );

        const matches = [...transactionText.matchAll(tableRegex)];

        // Define Headers for RBL Bank Statement
        const headers = [
          "Date",
          "Particulars/Description",
          "Amount",
          "Balance",
          "",
          "",
          "",
        ];

        const dataRows = matches.map((m) => {
          const g = m.groups;
          return [
            g.date,
            g.particular.trim(),
            // Clean the amounts (remove commas and spaces)
            g.amt.replace(/,/g, "").replace(/\s/g, ""),
            // Clean the balance (remove spaces)
            g.bal.replace(/\s/g, ""),
            "",
            "",
            "", // Pad to 7 columns
          ];
        });

        const allRows = [
          ...metadataRows,
          headers,
          ...dataRows,
        ];

        return { allRows };
      }

      // --- Parser 7: IDBI Bank Statement ---
      function parseIDBIBankStatementText(rawText) {
        console.log("Starting IDBI Bank parsing."); // DEBUG

        // 1. Metadata Extraction (using dotAll flag 's')
        // Regex: /^(?<Name>.*)  Address .* A\/C NO: (?<AccNo>\d+)/s
        const metadataRegex =
          /^(?<Name>.*?) Address .* A\/C NO: (?<AccNo>\d+)/s;
        const metadataMatch = rawText.match(metadataRegex);

        const metadataRows = [
          [
            "Account Name",
            metadataMatch?.groups?.Name?.trim() || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
          [
            "Account Number",
            metadataMatch?.groups?.AccNo || "N/A",
            "",
            "",
            "",
            "",
            "",
          ],
        ];

        console.log("IDBI Metadata:", metadataRows); // DEBUG

        // 2. Transaction Table Extraction
        // Regex: (?<date>\d\d\/\d\d\/\d{4}) (.*?) (Dr\.|Cr\.) \w{3} (?<Amt>[\d,]+\.\d{2}) \d\d\/\d\d\/\d{4} \d\d:\d\d:\d\d (?<serialNo>\d+) (?<Bal>-?[\d,]+\.\d{2})
        // Note: The second capture group (.*?) holds the particulars/description.
        const tableRegex = new RegExp(
          /(?<date>\d\d\/\d\d\/\d{4})\s+(?<particular>.*?)\s+(?<type>Dr\.|Cr\.)\s+\w{3}\s+(?<Amt>[\d,]+\.\d{2})\s+\d\d\/\d\d\/\d{4}\s+\d\d:\d\d:\d\d\s+(?<serialNo>\d+)\s+(?<Bal>-?[\d,]+\.\d{2})/g,
        );

        // Run the regex over the raw text
        const matches = [...rawText.matchAll(tableRegex)];

        console.log(`IDBI found ${matches.length} transactions.`); // DEBUG

        // Define Headers for IDBI Bank Statement
        const headers = [
          "Date",
          "Particulars/Description",
          "Type",
          "Amount",
          "Serial No",
          "Balance",
          "",
        ];

        const dataRows = matches.map((m) => {
          const g = m.groups;

          // Determine the actual amount based on Dr/Cr type
          const amount = g.type === "Dr." ? `-${g.Amt}` : g.Amt;

          return [
            g.date,
            g.particular.trim(),
            g.type,
            amount.replace(/,/g, ""), // Clean commas from amount
            g.serialNo,
            g.Bal.replace(/,/g, ""), // Clean commas from balance
            "", // Pad to 7 columns
          ];
        });

        const allRows = [
          ...metadataRows,
          headers,
          ...dataRows,
        ];

        return { allRows };
      }

      function copyTable() {
        if (store.allRows.length === 0) return;

        const tsvText = store.allRows.map((row) => row.join("\t")).join(
          "\n",
        );

        const tempTextArea = document.createElement("textarea");
        tempTextArea.style.position = "fixed";
        tempTextArea.style.opacity = "0";
        tempTextArea.value = tsvText;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();

        try {
          document.execCommand("copy");
          setStatus("All table data copied to clipboard!", "success");
        } catch (err) {
          setStatus("Manual copy required.", "error");
        } finally {
          document.body.removeChild(tempTextArea);
          setTimeout(clearStatus, 3000);
        }
      }

      // --- Templates ---

      const statusTemplate = html`
        ${() => {
          if (!store.status.message) return "";
          const baseClasses = "p-4 rounded-lg text-sm mb-6";
          const typeClasses = store.status.type === "error"
            ? "bg-red-100 text-red-800"
            : store.status.type === "success"
            ? "bg-green-100 text-green-800"
            : "bg-blue-100 text-blue-800";
          return html`
            <div class="${baseClasses} ${typeClasses}" role="alert">${store
              .status.message}</div>
          `;
        }}
      `;

      const tableTemplate = html`
        <div class="overflow-x-auto border rounded-lg">
          <table id="outputTable">
            <tbody>
              ${() =>
                store.allRows.map((row, index) => {
                  // Identify row types for styling
                  const isSourceHeader = row[0] &&
                    row[0].startsWith("Source:");
                  // Heuristic for header rows based on first cell content
                  const firstCell = row[0] || "";
                  const isHeader =
                    (firstCell === "Head" && row[1] === "Tax") ||
                    (firstCell === "Description" &&
                      row[1] === "Taxable Value") ||
                    (firstCell === "Section No" &&
                      row[1] === "Amount (Rs.)") ||
                    (firstCell === "Date" &&
                      row[1] === "Particulars/Description");

                  let rowClass = "";
                  if (isSourceHeader) rowClass = "file-row";
                  else if (isHeader) rowClass = "header-row";

                  return html`
                    <tr class="${rowClass}">
                      ${row.map((cell) =>
                        html`
                          <td>${cell}</td>
                        `
                      )}
                    </tr>
                  `;
                })}
            </tbody>
          </table>
        </div>
      `;

      const resultsTemplate = html`
        ${() => {
          if (!store.isResultVisible) return "";
          return html`
            <div>
              <h2 class="text-2xl font-semibold text-gray-700 mb-4 border-b pb-2">
                Extracted Data
              </h2>

              <div
                class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg"
              >
                <p class="text-sm font-medium text-yellow-800 mb-3 md:mb-0">
                  <span class="font-bold">Instructions:</span> Copy the table below
                  to paste into Excel.
                </p>
                <div class="flex space-x-4 w-full md:w-auto">
                  <!-- Table Visibility Toggle -->
                  <button
                    @click="${() =>
                      store.isTableVisible = !store.isTableVisible}"
                    class="flex-shrink-0 w-full md:w-auto px-4 py-2 text-white font-bold rounded-lg shadow transition duration-150 ${() =>
                      store.isTableVisible
                        ? "bg-blue-500 hover:bg-blue-600"
                        : "bg-gray-500 hover:bg-gray-600"}"
                  >
                    ${() =>
                      store.isTableVisible
                        ? "Hide Table"
                        : "Show Table"}
                  </button>
                  <!-- Copy Button -->
                  <button
                    @click="${copyTable}"
                    class="flex-shrink-0 w-full md:w-auto px-4 py-2 bg-green-500 text-white font-bold rounded-lg shadow hover:bg-green-600 transition duration-150"
                  >
                    Copy All to Clipboard
                  </button>
                </div>
              </div>

              <!-- Conditional Table Rendering -->
              ${() =>
                store.isTableVisible ? tableTemplate : html`
                  <div class="p-8 text-center text-gray-500 border rounded-lg bg-white">
                    The extracted data table is currently hidden. Click the "Show Table"
                    button above to view the data.
                  </div>
                `}

              <div class="mt-8">
                <h3 class="text-xl font-medium text-gray-700 mb-2">
                  Raw Extracted Text (For Debugging)
                </h3>
                <pre
                  class="bg-gray-100 p-4 rounded-lg text-xs overflow-auto max-h-64 border"
                >${() => store.rawText}</pre>
              </div>
            </div>
          `;
        }}
      `;

      // Helper to generate class string safely
      const dropZoneClass = () => {
        const base =
          "mb-8 p-10 border-2 border-dashed rounded-lg bg-blue-50 transition-all duration-200 flex flex-col items-center justify-center text-center cursor-pointer block";
        const active = store.isDragging
          ? "drag-active"
          : "border-blue-300";
        return `${base} ${active}`;
      };

      const mainTemplate = html`
        <div
          class="container mx-auto bg-white shadow-xl rounded-xl p-6 md:p-10"
        >
          <h1 class="text-3xl font-extrabold text-blue-800 mb-2">
            Tax & Bank Data Extractor
          </h1>
          <p class="text-gray-600 mb-6">
            Supports <strong>GST Receipts</strong>, <strong>GSTR-3B</strong>,
            <strong>TDS Challans</strong>, <strong>PF Receipts</strong>,<strong
            >PT challans</strong>, <strong>Union Bank</strong>,
            <strong>Canara Bank</strong>, <strong>RBL Bank</strong>, and <strong
            >IDBI Bank Statements</strong>.
            <br>Drag and drop multiple PDF files to process them in batch.
          </p>

          <!-- File Input / Drop Zone -->
          <label
            for="gstFileInput"
            class="${dropZoneClass}"
            @dragover="${(e) => handleDragOver(e)}"
            @dragleave="${(e) => handleDragLeave(e)}"
            @drop="${(e) => handleDrop(e)}"
          >
            <svg
              class="w-12 h-12 text-blue-500 mb-3"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
              >
              </path>
            </svg>

            <span
              class="block text-lg font-medium text-blue-700 mb-2 cursor-pointer"
            >
              ${() =>
                store.isDragging
                  ? "Drop files here"
                  : "Click to Upload or Drag & Drop"}
            </span>

            <span class="block text-sm text-gray-500 mb-4"
            >PDF files only (Multiple allowed)</span>
            <span class="block text-sm font-semibold text-blue-600"
            >${() => store.fileSummary}</span>

            <input
              type="file"
              id="gstFileInput"
              @change="${handleFileInput}"
              accept="application/pdf"
              class="hidden"
              multiple
            >
          </label>

          ${statusTemplate} ${resultsTemplate}
        </div>
      `;

      // Mount application
      mainTemplate(document.getElementById("app"));
    </script>
  </body>
</html>
