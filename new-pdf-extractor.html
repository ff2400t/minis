<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tax & Bank Data Extractor (SolidJS Refactored)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script>
        // Set the workerSrc for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
    </script>
    <style>
        .data-table {
            table-layout: fixed;
            width: 100%;
            border-collapse: collapse;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
        .data-table td, .data-table th {
            border: 1px solid #e5e7eb;
            padding: 8px;
            text-align: left;
            white-space: nowrap;
        }
        .data-table tr:nth-child(even) {
            background-color: #f9fafb;
        }
        .header-row td {
            background-color: #f3f4f6;
            font-weight: bold;
            color: #374151;
        }
        .file-row td {
            background-color: #bfdbfe; /* Blue-200 */
            font-weight: bold;
            color: #1e3a8a;
            border-top: 2px solid #3b82f6;
        }
        .container {
            max-width: 1024px;
        }
        .drag-active {
            border-color: #3b82f6 !important; /* blue-500 */
            background-color: #eff6ff !important; /* blue-50 */
            transform: scale(1.01);
            transition: all 0.2s ease;
        }
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
        }
        /* Custom scrollbar for regex blocks */
        .regex-scroll::-webkit-scrollbar {
            height: 6px;
        }
        .regex-scroll::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }
    </style>
</head>
<body class="bg-gray-50 p-4 md:p-8">

    <div id="app"></div>

    <script type="module">
        import { createSignal, batch, onMount, Show } from 'https://esm.sh/solid-js@1.8.16';
        import { createStore } from 'https://esm.sh/solid-js@1.8.16/store';
        import { render } from 'https://esm.sh/solid-js@1.8.16/web';
        import html from 'https://esm.sh/solid-js@1.8.16/html';
        
        // --- CONSTANTS ---
        const LOCAL_STORAGE_KEY = 'dataExtractorCustomParsers';

        // --- Store Setup ---
        const [store, setStore] = createStore({
            fileSummary: '',
            status: { message: '', type: '' },
            allRows: [], 
            consolidatedMetadata: [], 
            consolidatedTables: [], 
            rawText: '',
            isResultVisible: false,
            isDragging: false,
            isTableVisible: true,
            isRawTextVisible: false,
            isParserFormVisible: false, 
            isConsolidatedVisible: false, 
            
            isTemplatesModalVisible: false,
            templatesText: '',

            isParserListModalVisible: false,
            expandedParsers: {}, 

            customParsers: [], // Will be populated from localStorage
            newParser: { // Simplified, configText is the primary input
                configText: ''
            },
            passwordModal: {
                isOpen: false,
                fileName: '',
                passwordInput: '',
                useForSubsequent: false,
                resolve: null 
            },
            savedPassword: null
        });
        
        // --- Local Signals for Controlled Inputs ---
        // Only configTextInput remains
        const [configTextInput, setConfigTextInput] = createSignal('');

        // Helper to sync local signals with the store's initial/cleared state
        function syncLocalSignals() {
            // Only sync the config text input
            setConfigTextInput(store.newParser.configText);
        }

        let globalResolveHandler = null;

        // --- Local Storage Handlers ---

        function loadCustomParsers() {
            try {
                const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (stored) {
                    const parsers = JSON.parse(stored);
                    if (Array.isArray(parsers)) {
                        setStore('customParsers', parsers);
                    }
                }
            } catch (e) {
                console.error("Could not load custom parsers from localStorage:", e);
            }
        }

        function saveCustomParsers(parsers) {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(parsers));
            } catch (e) {
                console.error("Could not save custom parsers to localStorage:", e);
            }
        }

        // --- Core Parser Config and Handlers ---

        // Standard parser configuration (moved out for cleaner code)
        const BUILT_IN_PARSERS = [
            [
                "GST Challan",
                ["GOODS AND SERVICES TAX PAYMENT RECEIPT"],
                /Deposit Date : (?<DepositDate>.*?) .* GSTIN: (?<GSTIN>\w+) .* Name.*?: (?<Name>.*?) Address .* \d+  (?<State>.*?) SGST.*? Total Amount (?<TotalAmount>\d+)/s,
                /(?<Head>\w+)\(.*?\)\s+(?<Tax>-|\d+)\s+(?<Interest>-|\d+)\s+(?<Penalty>-|\d+)\s+(?<Fees>-|\d+)\s+(?<Others>-|\d+)\s+(?<Total>-|\d+)\s+/g,
                generalDocumentParser
            ],
            [
                "IDBI Bank Statement",
                ["IDBI Bank or other authorities"],
                /^(?<Name>.*?) Address .* A\/C NO: (?<AccountNo>\d+)/s,
                /(?<Date>\d\d\/\d\d\/\d{4})\s+(?<Particular>.*?)\s+(?<Effect>Dr\.|Cr\.)\s+\w{3}\s+(?<Amount>[\d,]+\.\d{2})\s+\d\d\/\d\d\/\d{4}\s+\d\d:\d\d:\d\d\s+(?<SerialNo>\d+)\s+(?<Balance>-?[\d,]+\.\d{2})/g,
                (text, metaRx, tableRx) => {
                    // Custom logic for IDBI Bank Statement (parseIDBIBankWrapper)
                    const metadataMatch = text.match(metaRx);
                    const metadataFields = {
                        'Account Name': metadataMatch?.groups?.Name?.trim() || 'N/A',
                        'Account Number': metadataMatch?.groups?.AccNo || 'N/A'
                    };
                    const metadataRows = Object.entries(metadataFields).map(([k,v]) => [k, v, '', '', '', '', '']);

                    const matches = [...text.matchAll(tableRx)];
                    const headers = ['Date', 'Particulars/Description', 'Type', 'Amount', 'Serial No', 'Balance', ''];
                    const dataRows = matches.map(m => {
                        const g = m.groups;
                        const amount = g.type === 'Dr.' ? `-${g.Amt}` : g.Amt;
                        return [g.date, g.particular.trim(), g.type, amount.replace(/,/g, ''), g.serialNo, g.Bal.replace(/,/g, ''), ''];
                    });
                    return { allRows: [...metadataRows, headers, ...dataRows], metadataFields };
                }
            ],
            [
                "GSTR-3B",
                ["Form GSTR-3B", "See rule 61(5)"],
                /Year (?<Year>[\d-]+)\s+Period\s+(.*)\s+GSTIN\s+of\s+the\s+supplier\s+(?<GSTIN>\w+)\s+2\(a\)\.\s+Legal\s+name\s+of\s+the\s+registered\s+person\s+(?<Name>.*)\s+2\(b\)/,
                /\([a-e]\s?\) (?!and)(.*?) (\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+(\d+\.\d\d|-)\s+/g,
                generalDocumentParser
            ],
            [
                "TDS Challan",
                ["INCOME TAX DEPARTMENT", "Challan Receipt"],
                /Nature of Payment : (?<Section_No>\w+)\s+Amount \(in\s+Rs\.\) : ‚Çπ (?<Amount>\d[\d,.]*).*(?<Deposit_Date>\d\d\-\s?\w{3}-\d{4})/g,
                undefined,
                generalDocumentParser
            ],
            [
                "Union Bank Statement",
                ["Union Bank of India", "Statement of Account"],
                /Statement of Account\s+(?<Account_Holder_Name>.*?)\s+.* Account No\s+(?<Account_Number>\d+)/is,
                /(?<Date>\d\d-\d\d-\d{4})\s+\d\d:\d\d:\d\d\s+(?<Particulars>.*?)\s+(?<Amount>[\d,]+\.\d\s?\d)\s+(?<Balance>-?\s?[\d,]+\.\d\s?\d)/g,
                generalDocumentParser
            ],
            [
                "Canara Bank Statement",
                ["Canara Bank does not"],
                /Account Number (?<Account_Number>\d+).* Opening Balance Rs\. (?<Opening_Balance>-?[\d,]+\.\d\d)\s+Closing Balance Rs\. (?<Closing_Balance>-?[\d,]+\.\d\d)/s,
                /\s\s(?<Date>\d\d-\d\d-\d{4})\s+\d\d:\d\d:\d\d\s+(?<Particulars>.*?)\s+(?<Amount>[\d+,]+\.\d\d)\s+(?<Balance>-?[\d+,]+\.\d\d)/g,
                generalDocumentParser
            ],
            [
                "RBL Bank Statement",
                ["RBL BANK LTD"],
                /Account Name: (?<Account_Name>.*?) Home Branch: .* in Account Number:\s+(?<Account_Number>\d+)\s+.* Opening Balance: ‚Çπ (?<Opening_Balance>[\d,]+\.\d{2})\s+Count Of Debit: \d+\s+Closing Balance: ‚Çπ (?<Closing_Balance>[\d,]+\.\d{2})/s,
                /(?<Date>\d\d\/\d\d\/\d{4})\s+\d\d\/\d\d\/\d{4}\s+(?<Particular>.*?)\s+(?<Amount>[\d,]+\.\s?\d\s?\d)\s+(?<Balance>[\d,]+\s?\.\s?\d\s?\d)/g,
                generalDocumentParser
            ],
           
        ];
        
        // --- Helper Actions and General Parser (functions remain the same) ---
        
        function setStatus(message, type = 'info') {
            setStore('status', { message, type });
        }

        function clearStatus() {
            setStore('status', { message: '', type: '' });
        }

        function generalDocumentParser(text, metadataRegex, tableRegex, fieldsToExtract) {
            let metadataRows = [];
            let metadataFields = {};
            
            // 1. Metadata Extraction
            if (metadataRegex) {
                try {
                    const metaMatch = text.match(metadataRegex);
                    if (metaMatch && metaMatch.groups) {
                        for (const [key, value] of Object.entries(metaMatch.groups)) {
                            const val = value ? value.trim() : '';
                            metadataFields[key] = val;
                            metadataRows.push([key, val, '', '', '', '', '']);
                        }
                    } else if (metaMatch) {
                        for (let i = 1; i < metaMatch.length; i++) {
                             const val = metaMatch[i] ? metaMatch[i].trim() : '';
                             const key = fieldsToExtract && fieldsToExtract[i-1] ? fieldsToExtract[i-1] : `Meta ${i}`;
                             metadataFields[key] = val;
                             metadataRows.push([key, val, '', '', '', '', '']);
                        }
                    }
                } catch (e) { console.error("Metadata Regex Error", e); }
            }

            // 2. Table Extraction
            let headers = [];
            let dataRows = [];
            
            if (tableRegex) {
                try {
                    const matches = [...text.matchAll(tableRegex)];
                    if (matches.length > 0) {
                        const firstMatch = matches[0];
                        if (firstMatch.groups) {
                            headers = Object.keys(firstMatch.groups).map(k => k.charAt(0).toUpperCase() + k.slice(1).replace(/_/g, ' '));
                        } else {
                            headers = Array.from({length: firstMatch.length - 1}, (_, i) => `Col ${i+1}`);
                        }
                        
                        while (headers.length < 7) headers.push('');
                        if (headers.length > 7) headers = headers.slice(0, 7);

                        dataRows = matches.map(m => {
                            let row = [];
                            if (m.groups) row = Object.values(m.groups).map(val => val ? val.trim().replace(/,/g, '') : '');
                            else row = m.slice(1).map(val => val ? val.trim().replace(/,/g, '') : '');
                            
                            while (row.length < 7) row.push('');
                            return row.slice(0, 7);
                        });
                    }
                } catch (e) { console.error("Table Regex Error", e); }
            }

            return { allRows: [...metadataRows, headers, ...dataRows], metadataFields };
        }

        function parseConfigBlock(text) {
            // Function to safely extract content between two keys
            const getValue = (key, nextKeys) => {
                const lowerText = text.toLowerCase();
                const keyIndex = lowerText.indexOf(key.toLowerCase());
                
                if (keyIndex === -1) return null;
                
                const contentStart = keyIndex + key.length;
                let endIndex = text.length;
                
                nextKeys.forEach(nk => {
                    const nkIndex = lowerText.indexOf(nk.toLowerCase(), contentStart);
                    if (nkIndex !== -1 && nkIndex < endIndex) {
                        endIndex = nkIndex;
                    }
                });
                
                let val = text.substring(contentStart, endIndex).trim();
                // Remove trailing comma if present, which is common when copying
                if (val.endsWith(',')) val = val.slice(0, -1).trim(); 
                return val;
            };

            // These are the keys we look for
            const keys = ['Name:', 'matchstring:', 'Metadata:', 'Table:'];
            const name = getValue('Name:', keys.filter(k => k !== 'Name:'));
            const matchString = getValue('matchstring:', keys.filter(k => k !== 'matchstring:'));
            const metadataRegex = getValue('Metadata:', keys.filter(k => k !== 'Metadata:'));
            const tableRegex = getValue('Table:', keys.filter(k => k !== 'Table:'));

            return { name, matchString, metadataRegex, tableRegex };
        }
        
        // Only update the single input signal
        const handleConfigTextUpdate = (e) => {
            setConfigTextInput(e.target.value);
            setStore('newParser', 'configText', e.target.value);
        };
        
        function addCustomParser() {
            // Get data from the single config text input
            const configText = configTextInput();
            const data = parseConfigBlock(configText);

            const name = data.name;
            const matchString = data.matchString;
            const metadataRegex = data.metadataRegex;
            const tableRegex = data.tableRegex;

            if (!name || !matchString) {
                setStatus("Parser Name (Name:) and Match Strings (matchstring:) are required in the config block.", 'error');
                return;
            }

            // Validate Regex strings
            try {
                if (metadataRegex) new RegExp(metadataRegex);
                if (tableRegex) new RegExp(tableRegex);
            } catch (e) {
                setStatus(`Invalid Regex: ${e.message}`, 'error');
                return;
            }

            const newParser = {
                name,
                matchString: matchString.split(',').map(s => s.trim()).filter(s => s.length > 0), 
                metadataRegex: metadataRegex || '',
                tableRegex: tableRegex || ''
            };
            
            // Check for valid match strings
            if (newParser.matchString.length === 0) {
                setStatus("The matchstring: value cannot be empty.", 'error');
                return;
            }


            const currentParsers = [...store.customParsers];
            // Look for existing parser by name for upsert logic
            const existingIndex = currentParsers.findIndex(p => p.name === name);

            let newParserList;
            let action;

            if (existingIndex !== -1) {
                // Update existing parser
                currentParsers[existingIndex] = newParser;
                newParserList = currentParsers;
                action = "updated";
            } else {
                // Add new parser
                newParserList = [...currentParsers, newParser];
                action = "added";
            }


            batch(() => {
                setStore('customParsers', newParserList); // Update store
                saveCustomParsers(newParserList);        // Save to storage
                setStore('newParser', 'configText', ''); // Clear store state
                setConfigTextInput('');                  // Clear input field
                setStore('isParserFormVisible', false);
            });

            setStatus(`Custom parser "${name}" successfully ${action}!`, 'success');
        }

        function removeCustomParser(index) {
            const name = store.customParsers[index].name;
            const current = [...store.customParsers];
            current.splice(index, 1);
            setStore('customParsers', current);
            saveCustomParsers(current); // Save to storage
            setStatus(`Custom parser "${name}" removed.`, 'info');
        }

        function openTemplatesModal() {
            const text = store.customParsers.map(p => {
                return `Name: ${p.name}\nmatchstring: ${p.matchString.join(', ')}\nMetadata: ${p.metadataRegex || ''}\nTable: ${p.tableRegex || ''}`;
            }).join('\n\n---\n\n');
            batch(() => {
                setStore('templatesText', text);
                setStore('isTemplatesModalVisible', true);
            });
        }

        function saveTemplates() {
            const raw = store.templatesText;
            let blocks = [];
            // Split by separator '---' or by two or more newlines
            if (raw.includes('---')) {
                blocks = raw.split('---');
            } else {
                // This splits by any occurrence of two or more newlines
                blocks = raw.split(/\n\s*\n/);
            }

            const newParsers = [];
            for (const block of blocks) {
                const cleanBlock = block.trim();
                if (!cleanBlock) continue;
                const data = parseConfigBlock(cleanBlock);
                
                // Only save if required fields are present
                if (data.name && data.matchString) {
                    newParsers.push({
                        name: data.name,
                        matchString: data.matchString.split(',').map(s => s.trim()).filter(s => s.length > 0),
                        metadataRegex: data.metadataRegex || '',
                        tableRegex: data.tableRegex || ''
                    });
                }
            }
            batch(() => {
                setStore('customParsers', newParsers);
                setStore('isTemplatesModalVisible', false);
                saveCustomParsers(newParsers); // Save to storage
            });
            setStatus(`Updated ${newParsers.length} custom parsers.`, 'success');
        }
        
        function toggleParserDetails(id) {
            setStore('expandedParsers', id, !store.expandedParsers[id]);
        }

        // --- File Handling & Processing (Simplified for brevity, similar to previous) ---

        function handleDragOver(e) { if (e) { e.preventDefault(); e.stopPropagation(); } setStore('isDragging', true); }
        function handleDragLeave(e) { if (e) { e.preventDefault(); e.stopPropagation(); } setStore('isDragging', false); }
        function handleDrop(e) { if (!e) return; e.preventDefault(); e.stopPropagation(); setStore('isDragging', false); const dt = e.dataTransfer; const files = dt ? dt.files : null; if (files && files.length > 0) processFiles(files); }
        function handleFileInput(e) { processFiles(e.target.files); }

        async function extractAllPdfText(file, password = "") {
            const fileReader = new FileReader();
            return new Promise((resolve, reject) => {
                fileReader.onload = async function() {
                    const typedarray = new Uint8Array(this.result);
                    try {
                        const pdf = await pdfjsLib.getDocument({ data: typedarray, password: password }).promise;
                        let fullText = '';
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            fullText += textContent.items.map(item => item.str).join(' ') + ' '; 
                        }
                        resolve(fullText);
                    } catch (error) { reject(error); }
                };
                fileReader.onerror = () => reject(new Error("Error reading file."));
                fileReader.readAsArrayBuffer(file);
            });
        }

        async function extractTextWithPasswordHandling(file) {
            try {
                return await extractAllPdfText(file, "");
            } catch (e) {
                if (e.name === 'PasswordException') {
                    if (store.savedPassword) {
                        try {
                            return await extractAllPdfText(file, store.savedPassword);
                        } catch (e2) { if (e2.name !== 'PasswordException') throw e2; }
                    }
                    while (true) {
                        const userResponse = await promptForPassword(file.name);
                        if (userResponse.skip) throw new Error("Skipped by user");
                        try {
                            const text = await extractAllPdfText(file, userResponse.password);
                            if (userResponse.useForSubsequent) setStore('savedPassword', userResponse.password);
                            return text;
                        } catch (e3) {
                            if (e3.name !== 'PasswordException') throw e3;
                            console.error("Incorrect password. Please try again."); 
                            setStatus("Incorrect password. Please try again.", 'error');
                        }
                    }
                }
                throw e; 
            }
        }

        function promptForPassword(fileName) {
            return new Promise((resolve) => {
                batch(() => {
                    setStore('passwordModal', 'fileName', fileName);
                    setStore('passwordModal', 'passwordInput', '');
                    setStore('passwordModal', 'useForSubsequent', false);
                    setStore('passwordModal', 'isOpen', true);
                    globalResolveHandler = resolve
                });
            });
        }

        function handlePasswordSubmit() {
                globalResolveHandler({
                    password: store.passwordModal.passwordInput,
                    useForSubsequent: store.passwordModal.useForSubsequent,
                    skip: false
                });
                globalResolveHandler = null
                batch(() => {
                    setStore('passwordModal', 'isOpen', false);
                    setStore('passwordModal', 'resolve', null);
                });
        }

        function handlePasswordSkip() {
            // if (store.passwordModal.resolve) {
                globalResolveHandler({ skip: true });
                globalResolveHandler = null;
                batch(() => {
                    setStore('passwordModal', 'isOpen', false);
                    setStore('passwordModal', 'resolve', null);
                });
            
        }

        async function processFiles(fileList) {
            // ... (file processing logic remains the same)
            if (!fileList || fileList.length === 0) {
                batch(() => {
                    setStore('fileSummary', '');
                    setStore('isResultVisible', false);
                    clearStatus();
                });
                return;
            }

            const count = fileList.length;
            setStore('fileSummary', count === 1 ? `File: ${fileList[0].name}` : `${count} files selected`);
            
            batch(() => {
                setStore('isResultVisible', false);
                setStore('rawText', '');
                setStore('allRows', []);
                setStore('consolidatedMetadata', []);
                setStore('consolidatedTables', []);
                setStore('isTableVisible', true);
                setStore('isRawTextVisible', false);
                setStore('isConsolidatedVisible', false);
                setStore('savedPassword', null);
            });

            let successCount = 0;
            let tempAllRows = [];
            let tempRawText = '';
            let tempMetadata = [];

            try {
                for (let i = 0; i < count; i++) {
                    const file = fileList[i];
                    if (file.type !== 'application/pdf') {
                        console.log(`Skipping file: ${file.name} (Not a PDF)`);
                        continue; 
                    }

                    setStatus(`Processing ${i + 1} of ${count}: ${file.name}...`, 'info');
                    
                    let rawText;
                    try {
                        rawText = await extractTextWithPasswordHandling(file);
                    } catch (extractionError) {
                        tempRawText += `\n--- SOURCE: ${file.name} (FAILED) ---\nError: ${extractionError.message}\n`;
                        continue;
                    }
                    
                    rawText = rawText.replace(/   /g, ' '); 

                    let parsedData = { allRows: [], metadataFields: {} };
                    let docType = "Unknown";
                    const cleanCheckText = rawText.replace(/\s+/g, ' ');

                    let parserFound = false;

                    // 1. Check CUSTOM Parsers
                    for (const parser of store.customParsers) {
                        const isMatch = parser.matchString.some(s => cleanCheckText.includes(s));
                        if (isMatch) {
                            docType = parser.name + " (Custom)";
                            // Note: Custom parsers always use generalDocumentParser logic with their defined regex
                            parsedData = generalDocumentParser(rawText, parser.metadataRegex, parser.tableRegex);
                            parserFound = true;
                            break;
                        }
                    }

                    // 2. Check BUILT-IN Parsers (Array iteration)
                    if (!parserFound) {
                        for (const [name, matches, metaRx, tableRx, parserFn] of BUILT_IN_PARSERS) {
                            const isMatch = matches.some(s => cleanCheckText.includes(s));
                            if (isMatch) {
                                docType = name;
                                parsedData = parserFn(rawText, metaRx, tableRx);
                                parserFound = true;
                                break;
                            }
                        }
                    }

                    if (!parserFound) {
                        tempRawText += `\n--- SOURCE: ${file.name} (Unknown Type) ---\n${rawText}\n`;
                        console.log(`Document type unknown for: ${file.name}`);
                        continue;
                    }

                    if (parsedData.metadataFields && Object.keys(parsedData.metadataFields).length > 0) {
                        tempMetadata.push({
                            fileName: file.name,
                            docType: docType,
                            fields: parsedData.metadataFields
                        });
                    }

                    tempRawText += `\n--- SOURCE: ${file.name} (${docType}) ---\n${rawText}\n`;

                    const fileLabelRow = [`Source: ${file.name} (${docType})`, '', '', '', '', '', ''];
                    if (tempAllRows.length > 0) tempAllRows.push(['', '', '', '', '', '', '']); 
                    tempAllRows.push(fileLabelRow);
                    tempAllRows.push(...parsedData.allRows);
                    
                    successCount++;
                }

                // Batch update state at the end
                batch(() => {
                    setStore('allRows', tempAllRows);
                    setStore('rawText', tempRawText);
                    setStore('consolidatedMetadata', tempMetadata);
                    
                    const tables = generateConsolidatedTables(tempMetadata);
                    setStore('consolidatedTables', tables);

                    setStore('isResultVisible', true);
                    
                    if (tempAllRows.length === 0 && tempMetadata.length === 0) {
                        setStatus("Processed files but found no recognized data.", 'info');
                    } else {
                        setStatus(`Successfully processed ${successCount} files!`, 'success');
                    }
                });

            } catch (error) {
                console.error(error);
                setStatus(`Error: ${error.message}`, 'error');
                setStore('isResultVisible', true);
            }
        }

        function generateConsolidatedTables(metadataList) {
            const groups = {};
            metadataList.forEach(item => {
                if (!groups[item.docType]) groups[item.docType] = [];
                groups[item.docType].push(item);
            });

            return Object.keys(groups).map(type => {
                const items = groups[type];
                const keys = new Set();
                items.forEach(i => Object.keys(i.fields).forEach(k => keys.add(k)));
                const header = Array.from(keys);
                
                const rows = items.map(item => {
                    const rowData = [item.fileName];
                    header.forEach(h => {
                        rowData.push(item.fields[h] || '');
                    });
                    return rowData;
                });

                return {
                    title: type,
                    headers: ['Source File', ...header],
                    rows: rows
                };
            });
        }

        function copyTable(tableId = 'outputTable') {
            const table = document.getElementById(tableId);
            if (!table) return;
            const rows = Array.from(table.rows).map(row => 
                Array.from(row.cells).map(cell => cell.innerText).join('\t')
            ).join('\n');
            const tempTextArea = document.createElement('textarea');
            tempTextArea.style.position = 'fixed';
            tempTextArea.style.opacity = '0';
            tempTextArea.value = rows;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            try {
                document.execCommand('copy');
                setStatus("Table content copied to clipboard!", 'success');
            } catch (err) {
                setStatus("Manual copy required.", 'error');
            } finally {
                document.body.removeChild(tempTextArea);
                setTimeout(() => clearStatus(), 3000);
            }
        }

        // --- Refactored Components for Reactivity Isolation ---

        // CRITICAL FIX: Isolated component for input fields to prevent focus loss
        const ParserFormInputs = () => html`
            <div class="p-6 bg-white border-t">
                ${() => store.customParsers.length > 0 ? html`
                    <div class="mb-6 p-4 bg-indigo-50 rounded-lg border border-indigo-100">
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="font-bold text-indigo-800">Active Custom Parsers:</h4>
                            <button 
                                onClick=${openTemplatesModal}
                                class="text-xs bg-indigo-600 text-white px-2 py-1 rounded hover:bg-indigo-700"
                            >
                                Edit / Export All
                            </button>
                        </div>
                        <ul class="space-y-2">
                            ${store.customParsers.map((p, i) => html`
                                <li class="flex justify-between items-center bg-white p-2 rounded shadow-sm">
                                    <div>
                                        <span class="font-semibold text-gray-800">${p.name}</span>
                                        <span class="text-xs text-gray-500 ml-2">(Match: ${p.matchString.join(', ')})</span>
                                    </div>
                                    <button onClick=${() => removeCustomParser(i)} class="text-red-500 hover:text-red-700 text-sm font-medium px-2">Remove</button>
                                </li>
                            `)}
                        </ul>
                    </div>
                ` : ''}

                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Quick Import (Paste Config Block)</label>
                    <textarea 
                        class="w-full h-48 rounded-md border-gray-300 shadow-sm border p-2 text-sm font-mono"
                        placeholder="Define your parser here using the required keys.&#10;&#10;Name: My Custom Bank Statement&#10;matchstring: Bank Statement, Account Summary, MyBankCorp&#10;Metadata: /Account Number: (?<AccNo>\\d+).*?Name: (?<Name>.*?)/s&#10;Table: /(?<Date>\\d{2}\\.\\d{2}\\.\\d{4})\\s+.*\\s+(?<Amount>\\d+)/g"
                        value=${configTextInput()}
                        onInput=${handleConfigTextUpdate}
                    ></textarea>
                    <p class="text-xs text-gray-500 mt-1">
                        Define your parser using the keys: <code class="font-semibold">Name:</code>, <code class="font-semibold">matchstring:</code> (comma-separated document identifiers), <code class="font-semibold">Metadata:</code> (single-match regex for key info), and <code class="font-semibold">Table:</code> (global-match regex for rows).
                    </p>
                </div>

                <button 
                    onClick=${addCustomParser}
                    class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700"
                >
                    Add / Update Parser
                </button>
            </div>
        `;

        const ParserForm = () => html`
            <div class="mb-6 border rounded-lg overflow-hidden">
                <button 
                    class="w-full text-left px-6 py-4 bg-gray-100 font-semibold text-gray-700 hover:bg-gray-200 flex justify-between items-center"
                    onClick=${() => setStore('isParserFormVisible', !store.isParserFormVisible)}
                >
                    <span>üõ†Ô∏è Configure Custom Parser (Add/Update/Import)</span>
                    <span>${store.isParserFormVisible ? '‚ñ≤' : '‚ñº'}</span>
                </button>

                <${Show} when=${() => store.isParserFormVisible}>
                    <${ParserFormInputs} />
                <//>
            </div>
        `;

        const PasswordModalComponent = () => html`
            <div class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">Password Required</h3>
                    <p class="text-sm text-gray-600 mb-2">
                        The file <span class="font-bold text-blue-600">${store.passwordModal.fileName}</span> is encrypted.
                    </p>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Enter Password</label>
                        <input 
                            type="text" 
                            class="w-full border border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            placeholder="Password"
                            value=${store.passwordModal.passwordInput}
                            onInput=${(e) => setStore('passwordModal', 'passwordInput', e.target.value)}
                            onKeyDown=${(e) => e.key === 'Enter' && handlePasswordSubmit()}
                        />
                    </div>

                    <div class="flex items-center mb-6">
                        <input 
                            type="checkbox" 
                            id="useForSubsequent"
                            class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                            checked=${store.passwordModal.useForSubsequent}
                            onChange=${(e) => setStore('passwordModal', 'useForSubsequent', e.target.checked)}
                        />
                        <label for="useForSubsequent" class="ml-2 block text-sm text-gray-700">
                            Use this password for subsequent files
                        </label>
                    </div>

                    <div class="flex justify-end space-x-3">
                        <button 
                            onClick=${handlePasswordSkip}
                            class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium text-sm"
                        >
                            Skip File
                        </button>
                        <button 
                            onClick=${handlePasswordSubmit}
                            class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium text-sm"
                        >
                            Decrypt & Extract
                        </button>
                    </div>
                </div>
            </div>
        `;

        const TemplatesModalComponent = () => html`
            <div class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-2xl mx-4 flex flex-col max-h-[90vh]">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-gray-800">Manage All Custom Parsers</h3>
                        <button 
                            onClick=${() => setStore('isTemplatesModalVisible', false)}
                            class="text-gray-500 hover:text-gray-700"
                        >
                            ‚úï
                        </button>
                    </div>
                    <p class="text-sm text-gray-600 mb-4">Edit all parsers below or paste a list to import multiple. Separate parsers with <code class="font-mono">---</code> or two blank lines.</p>
                    
                    <textarea 
                        class="flex-grow w-full border border-gray-300 rounded-lg p-3 font-mono text-xs mb-4 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        rows="15"
                        value=${store.templatesText}
                        onInput=${(e) => setStore('templatesText', e.target.value)}
                    ></textarea>

                    <div class="flex justify-end space-x-3">
                        <button 
                            onClick=${() => setStore('isTemplatesModalVisible', false)}
                            class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium text-sm"
                        >
                            Cancel
                        </button>
                        <button 
                            onClick=${saveTemplates}
                            class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium text-sm"
                        >
                            Save All Changes
                        </button>
                    </div>
                </div>
            </div>
        `;

        const ParserListModalComponent = () => html`
            <div class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-3xl mx-4 flex flex-col max-h-[90vh]">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-gray-800">Available Parsers</h3>
                        <button 
                            onClick=${() => setStore('isParserListModalVisible', false)}
                            class="text-gray-500 hover:text-gray-700"
                        >
                            ‚úï
                        </button>
                    </div>
                    
                    <div class="flex-grow overflow-y-auto pr-2">
                        <h4 class="text-sm font-bold text-gray-500 uppercase tracking-wide mb-2">Built-in Parsers</h4>
                        <ul class="space-y-2 mb-6">
                            ${BUILT_IN_PARSERS.map((parser, idx) => {
                                const id = `builtin-${idx}`;
                                const name = parser[0];
                                const matchStrings = parser[1];
                                const metaRegex = parser[2];
                                const tableRegex = parser[3];
                                
                                return html`
                                    <li class="border rounded-lg p-3 bg-gray-50">
                                        <div class="flex justify-between items-center">
                                            <div>
                                                <span class="font-bold text-gray-800 block">${name}</span>
                                                <span class="text-xs text-gray-500">Matches: ${matchStrings.join(', ')}</span>
                                            </div>
                                            <button 
                                                onClick=${() => toggleParserDetails(id)}
                                                class="text-blue-600 hover:text-blue-800 text-xs font-semibold px-2 py-1 border border-blue-200 rounded hover:bg-blue-50"
                                            >
                                                ${() => store.expandedParsers[id] ? 'Hide Regex' : 'Show Regex'}
                                            </button>
                                        </div>
                                        <${Show} when=${() => store.expandedParsers[id]}>
                                            <div class="mt-3 text-xs font-mono bg-white p-2 rounded border border-gray-200 regex-scroll overflow-x-auto">
                                                <div class="mb-2">
                                                    <strong class="text-purple-700">Metadata Regex:</strong><br/>
                                                    <span class="text-gray-700">${metaRegex ? metaRegex.toString() : 'N/A'}</span>
                                                </div>
                                                <div>
                                                    <strong class="text-teal-700">Table Regex:</strong><br/>
                                                    <span class="text-gray-700">${tableRegex ? tableRegex.toString() : 'N/A'}</span>
                                                </div>
                                            </div>
                                        <//>
                                    </li>
                                `;
                            })}
                        </ul>

                        <${Show} when=${() => store.customParsers.length > 0}>
                            <h4 class="text-sm font-bold text-gray-500 uppercase tracking-wide mb-2">Custom Parsers</h4>
                            <ul class="space-y-2">
                                ${store.customParsers.map((parser, idx) => {
                                    const id = `custom-${idx}`;
                                    
                                    return html`
                                        <li class="border rounded-lg p-3 bg-indigo-50 border-indigo-100">
                                            <div class="flex justify-between items-center">
                                                <div>
                                                    <span class="font-bold text-indigo-900 block">${parser.name}</span>
                                                    <span class="text-xs text-indigo-600">Matches: ${parser.matchString.join(', ')}</span>
                                                </div>
                                                <button 
                                                    onClick=${() => toggleParserDetails(id)}
                                                    class="text-indigo-600 hover:text-indigo-800 text-xs font-semibold px-2 py-1 border border-indigo-200 rounded hover:bg-indigo-100"
                                                >
                                                    ${() => store.expandedParsers[id] ? 'Hide Regex' : 'Show Regex'}
                                                </button>
                                            </div>
                                            <${Show} when=${() => store.expandedParsers[id]}>
                                                <div class="mt-3 text-xs font-mono bg-white p-2 rounded border border-gray-200 regex-scroll overflow-x-auto">
                                                    <div class="mb-2">
                                                        <strong class="text-purple-700">Metadata Regex:</strong><br/>
                                                        <span class="text-gray-700">${parser.metadataRegex || 'N/A'}</span>
                                                    </div>
                                                    <div>
                                                        <strong class="text-teal-700">Table Regex:</strong><br/>
                                                        <span class="text-gray-700">${parser.tableRegex || 'N/A'}</span>
                                                    </div>
                                                </div>
                                            <//>
                                        </li>
                                    `;
                                })}
                            </ul>
                        <//>
                    </div>

                    <div class="mt-4 pt-4 border-t flex justify-end">
                        <button 
                            onClick=${() => setStore('isParserListModalVisible', false)}
                            class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 font-medium text-sm"
                        >
                            Close
                        </button>
                    </div>
                </div>
            </div>
        `;

        const ResultsDisplay = () => html`
            <div>
                <h2 class="text-2xl font-semibold text-gray-700 mb-4 border-b pb-2">Extracted Data</h2>
                
                <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                    <p class="text-sm font-medium text-yellow-800 mb-3 md:mb-0">
                        <span class="font-bold">Instructions:</span> View detailed data below or toggle summary views.
                    </p>
                    <div class="flex flex-wrap gap-2 w-full md:w-auto">
                        <button onClick=${() => setStore('isTableVisible', !store.isTableVisible)} class=${`flex-shrink-0 w-full md:w-auto px-4 py-2 text-white font-bold rounded-lg shadow transition duration-150 ${store.isTableVisible ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-500 hover:bg-gray-600'}`}>
                            ${() => store.isTableVisible ? 'Hide Details' : 'Show Details'}
                        </button>
                        <button onClick=${() => setStore('isConsolidatedVisible', !store.isConsolidatedVisible)} class=${`flex-shrink-0 w-full md:w-auto px-4 py-2 text-white font-bold rounded-lg shadow transition duration-150 ${store.isConsolidatedVisible ? 'bg-purple-500 hover:bg-purple-600' : 'bg-gray-500 hover:bg-gray-600'}`}>
                            ${() => store.isConsolidatedVisible ? 'Hide Metadata Summary' : 'Show Metadata Summary'}
                        </button>
                        <button onClick=${() => copyTable('outputTable')} class="flex-shrink-0 w-full md:w-auto px-4 py-2 bg-green-500 text-white font-bold rounded-lg shadow hover:bg-green-600 transition duration-150">
                            Copy Details
                        </button>
                    </div>
                </div>

                <${Show} when=${() => store.isConsolidatedVisible}>
                    <div class="mt-8 border-t pt-8">
                        <h2 class="text-2xl font-bold text-gray-800 mb-4">Consolidated Metadata Summary</h2>
                        <p class="text-gray-600 mb-4">A combined view of metadata across all processed files, grouped by document type.</p>
                        
                        ${store.consolidatedTables.map((tbl, i) => html`
                            <div class="mb-8">
                                <div class="flex justify-between items-center mb-3">
                                    <h3 class="text-lg font-semibold text-blue-700">${tbl.title}</h3>
                                    <button onClick=${() => copyTable(`consTable-${i}`)} class="px-3 py-1 bg-blue-100 text-blue-700 hover:bg-blue-200 rounded text-sm font-bold">
                                        Copy Table
                                    </button>
                                </div>
                                <div class="overflow-x-auto border rounded-lg shadow-sm">
                                    <table id=${`consTable-${i}`} class="data-table">
                                        <thead class="bg-gray-50">
                                            <tr>
                                                ${tbl.headers.map(h => html`<th class="font-bold text-gray-600">${h}</th>`)}
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${tbl.rows.map(row => html`
                                                <tr>
                                                    ${row.map(cell => html`<td>${cell}</td>`)}
                                                </tr>
                                            `)}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        `)}
                    </div>
                <//>

                <${Show} when=${() => store.isTableVisible} fallback=${html`<div class="p-8 text-center text-gray-500 border rounded-lg bg-white mt-6">The extracted data table is currently hidden.</div>`}>
                    <div class="mt-6">
                        <h3 class="text-lg font-bold text-gray-700 mb-2">Detailed Extraction</h3>
                        <div class="overflow-x-auto border rounded-lg">
                            <table id="outputTable" class="data-table">
                                <tbody>
                                    ${store.allRows.map((row) => {
                                        const isSourceHeader = row[0] && row[0].startsWith('Source:');
                                        let rowClass = isSourceHeader ? 'file-row' : '';
                                        
                                        return html`
                                            <tr class=${rowClass}>
                                                ${row.map(cell => html`<td>${cell}</td>`)}
                                            </tr>
                                        `;
                                    })}
                                </tbody>
                            </table>
                        </div>
                    </div>
                <//>

                <div class="mt-8">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-xl font-medium text-gray-700">Raw Extracted Text (For Debugging)</h3>
                        <button onClick=${() => setStore('isRawTextVisible', !store.isRawTextVisible)} class=${`px-3 py-1 text-sm text-white font-bold rounded shadow transition duration-150 ${store.isRawTextVisible ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-500 hover:bg-gray-600'}`}>
                            ${() => store.isRawTextVisible ? 'Hide Raw Text' : 'Show Raw Text'}
                        </button>
                    </div>
                    
                    <${Show} when=${() => store.isRawTextVisible} fallback=${html`<div class="p-4 bg-gray-50 border rounded text-xs text-gray-500 italic">Raw text hidden.</div>`}>
                        <pre class="bg-gray-100 p-4 rounded-lg text-xs overflow-auto max-h-64 border">${store.rawText}</pre>
                    <//>
                </div>
            </div>
        `;


        // --- Main App Component ---

        const App = () => {
            onMount(() => {
                syncLocalSignals(); 
                loadCustomParsers(); // Load parsers on startup
            });

            return html`<div class="container mx-auto bg-white shadow-xl rounded-xl p-6 md:p-10 relative">
                    <h1 class="text-3xl font-extrabold text-blue-800 mb-2">
                        Universal Data Extractor
                    </h1>
                    <p class="text-gray-600 mb-6">
                        Supports <strong>GST</strong>, <strong>Income Tax</strong>, and various <strong>Bank Statements</strong>.
                        <br>Drag & drop PDFs or define your own <strong>Custom Parser</strong> below.
                    </p>

                    <!-- Custom Parser Section (Now a Component) -->
                    <${ParserForm} />

                    <!-- Button to Show Available Parsers -->
                    <div class="mb-6 flex justify-end">
                        <button 
                            onClick=${() => setStore('isParserListModalVisible', true)}
                            class="text-sm bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded shadow flex items-center"
                        >
                            <span>‚ÑπÔ∏è Show Available Parsers</span>
                        </button>
                    </div>

                    <!-- Drop Zone -->
                    <label 
                        for="gstFileInput"
                        class=${`mb-8 p-10 border-2 border-dashed rounded-lg bg-blue-50 transition-all duration-200 flex flex-col items-center justify-center text-center cursor-pointer block ${store.isDragging ? 'drag-active' : 'border-blue-300'}`}
                        onDragOver=${handleDragOver}
                        onDragLeave=${handleDragLeave}
                        onDrop=${handleDrop}
                    >
                        <svg class="w-12 h-12 text-blue-500 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                        
                        <span class="block text-lg font-medium text-blue-700 mb-2 cursor-pointer">
                            ${() => store.isDragging ? "Drop files here" : "Click to Upload or Drag & Drop"}
                        </span>
                        
                        <span class="block text-sm text-gray-500 mb-4">PDF files only (Multiple allowed)</span>
                        <span class="block text-sm font-semibold text-blue-600">${() => store.fileSummary}</span>

                        <input type="file" id="gstFileInput" onChange=${handleFileInput} accept="application/pdf" class="hidden" multiple />
                    </label>

                    <!-- Status -->
                    <${Show} when=${() => store.status.message}>
                        <div class=${`p-4 rounded-lg text-sm mb-6 ${store.status.type === 'error' ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'}`} role="alert">
                            ${() => store.status.message}
                        </div>
                    <//>

                    <!-- Results Section (Now a Component) -->
                    <${Show} when=${() => store.isResultVisible}>
                        <${ResultsDisplay} />
                    <//>
                    
                    <!-- Modals (Now Components) -->
                    <${Show} when=${() => store.passwordModal.isOpen}>
                        <${PasswordModalComponent} />
                    <//>
                    <${Show} when=${() => store.isTemplatesModalVisible}>
                        <${TemplatesModalComponent} />
                    <//>
                    <${Show} when=${() => store.isParserListModalVisible}>
                        <${ParserListModalComponent} />
                    <//>
                </div>
            `;
        }

        // Mount application
        render(App, document.getElementById('app'));

    </script>
</body>
</html>
